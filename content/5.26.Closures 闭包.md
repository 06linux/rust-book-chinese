# 闭包
Rust不只有命名函数，也有匿名函数。匿名函数有一个相关的环境叫做“闭包”，因为它们包含在这个环境中。正如我们将看到的，Rust有大量它们的实现。

## 语法
闭包看起来像这样：

```rust
let plus_one = |x: i32| x + 1;

assert_eq!(2, plus_one(1));
```

我们创建了一个绑定，`plus_one`，并把它赋予一个闭包。闭包的参数位于管道（`|`）之中，而闭包体是一个表达式，在这个例子中，`x + 1`。记住`{}`是一个表达式，所以我们也可以拥有包含多行的闭包：

```rust
let plus_two = |x| {
    let mut result: i32 = x;

    result += 1;
    result += 1;

    result
};

assert_eq!(4, plus_two(2));
```

你会注意到闭包的一些方面与用`fn`定义的常规函数有点不同。第一个是我们并不需要标明闭包接收和返回参数的类型。我们可以：

```rust
let plus_one = |x: i32| -> i32 { x + 1 };

assert_eq!(2, plus_one(1));
```

不过我们并不必须这么写。为什么呢？基本上，这是出于“人体工程学”的原因。因为为命名函数指定全部类型有助于像文档和类型推断，而闭包的类型则很少有文档因为它们是匿名的，并且并不会产生像推断一个命名函数的类型这样的“远距离错误”。

第二个是语法是相似的，不过有点不同。我会增加空格来使它们看起来更像一点：

```rust
fn  plus_one_v1   (x: i32 ) -> i32 { x + 1 }
let plus_one_v2 = |x: i32 | -> i32 { x + 1 };
let plus_one_v3 = |x: i32 |          x + 1  ;
```

小区别，不过仍然是相似的。

## 闭包和它们的环境
闭包这样叫是因为它们“包含在环境中”。这看起来像：

```rust
let num = 5;
let plus_num = |x: i32| x + num;

assert_eq!(10, plus_num(5));
```

这个闭包，`plus_num`，引用了它作用域中的`let`绑定：`num`。更明确的说，它借用了绑定。如果我们做一些会与这个绑定冲突的事，我们会得到一个错误。像这一个：

```rust
let mut num = 5;
let plus_num = |x: i32| x + num;

let y = &mut num;
```

错误是：

```bash
error: cannot borrow `num` as mutable because it is also borrowed as immutable
    let y = &mut num;
                 ^~~
note: previous borrow of `num` occurs here due to use in closure; the immutable
  borrow prevents subsequent moves or mutable borrows of `num` until the borrow
  ends
    let plus_num = |x| x + num;
                   ^~~~~~~~~~~
note: previous borrow ends here
fn main() {
    let mut num = 5;
    let plus_num = |x| x + num;
    
    let y = &mut num;
}
^
```

一个啰嗦但有用的错误信息！如它所说，我们不能取得一个`num`的可变借用因为闭包已经借用了它。如果我们让闭包离开作用域，我们可以：

```rust
let mut num = 5;
{
    let plus_num = |x: i32| x + num;

} // plus_num goes out of scope, borrow of num ends

let y = &mut num;
```

如果你的闭包需要它，然而，相反Rust会取得所有权并移动环境：

```rust
let nums = vec![1, 2, 3];

let takes_nums = || nums;

println!("{:?}", nums);
```

这会给我们：

```bash
note: `nums` moved into closure environment here because it has type
  `[closure(()) -> collections::vec::Vec<i32>]`, which is non-copyable
let takes_nums = || nums;
                    ^~~~~~~
```

`Vec<T>`拥有它内容的所有权，并且因此，当我们在闭包中引用它时，我们必须取得`nums`的所有权。这与我们传递`nums`给一个取得它所有权的函数一样。

## `move`闭包
我们可以使用`move`关键字强制我们的闭包取得它环境的所有权：

```rust
let num = 5;

let owns_num = move |x: i32| x + num;
```

现在，即便关键字是`move`，变量遵循正常的移动语义。在这个例子中，`5`实现了`Copy`，所以`owns_num`取得一个`5`的拷贝的所有权。那么区别是？

```rust
let mut num = 5;

{ 
    let mut add_num = |x: i32| num += x;

    add_num(5);
}

assert_eq!(10, num);
```

所以在这个例子中，我们的闭包取得了一个`num`的可变引用，然后接着我们调用了`add_num`，它改变了其中的值，正如我们期望的。我们也需要将`add_num`声明为`mut`，因为我们会改变它的环境。

如果我们改为一个`move`闭包，这有些不同：

```rust
let mut num = 5;

{ 
    let mut add_num = move |x: i32| num += x;

    add_num(5);
}

assert_eq!(5, num);
```

我们只会得到`5`。与其获取一个我们`num`的可变借用，我们取得了一个拷贝的所有权。

另一个理解`move`闭包的方法：它给出了一个拥有自己栈帧的闭包。没有`move`，一个闭包可能会绑定在












到目前为止，我们已经写了不少Rust函数了，不过它们都有名字。Rust也允许我们创建匿名函数。Rust的匿名函数叫做*闭包*（*closures*）。闭包自身并不很有意思，不过当它们与用闭包作为参数的函数结合时，就可能灰常强大了。

让我们写一个闭包：
```rust
let add_one = |x| { 1 + x };

println!("The sum of 5 plus 1 is {}.", add_one(5));
```
我们用`|...| { ... }`语法来创建一个闭包，然后我们创建一个绑定方便我们后面使用它。注意我们调用闭包时使用绑定的名字和括号，就像我么调用命名函数一样。

让我们比较一下语法。这两个非常相似：
```rust
let add_one = |x: i32| -> i32 { 1 + x };
fn  add_one   (x: i32) -> i32 { 1 + x }
```
你可能注意到了，闭包会推断它参数和返回值的类型，所以你不需要声明它们。这与命名函数有所不同，它们默认返回单元（`()`）。

闭包和命名函数有一个巨大的区别，就在于1它们的名字：闭包“闭合了它的环境”。这是什么意思呢？它意味着：
```rust
fn main() {
    let x: i32 = 5;

    let printer = || { println!("x is: {}", x); };

    printer(); // prints "x is: 5"
}
```
`||`语法代表这个匿名闭包不带参数。没有它，我们就一块`{}`中的代码了。

换句话说，闭包可以访问定义它的作用域内的变量。闭包借用任何它使用的变量，所以下面是错误的：
```rust
fn main() {
    let mut x: i32 = 5;

    let printer = || { println!("x is: {}", x); };

    x = 6; // error: cannot assign to `x` because it is borrowed
}
```

## 移动闭包（Moving closures）
Rust第二种类型的闭包，叫做*移动闭包*（*moving closure*），移动闭包用`move`关键字来标明。移动闭包与正常闭包的区别是移动闭包总是获取它使用变量的所有权。正常闭包，相反，只是在自己所在的栈上创建一个引用。移动闭包在Rust的并发功能中最有用，所以我们现在先不讲它。我们会在“线程”部分更详细的介绍它。

## 闭包作为参数
闭包作为另一个函数的参数时最有用。这是个例子：
```rust
fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {
    f(x) + f(x)
}

fn main() {
    let square = |x: i32| { x * x };

    twice(5, square); // evaluates to 50
}
```
让我们把例子分开来看，从`main`开始：
```rust
let square = |x: i32| { x * x };
```
我们之前见过这个。我们创建了一个闭包获取一个整形，然后返回它的平方。
```rust
twice(5, square); // evaluates to 50
```
这一行更有意思。这里，我们调用函数，`twice`，我们传递了两个参数：一个整形，`5`，然后是我们的闭包，`square`。这跟向函数传递两个变量绑定并无区别，不过如果你之前并未接触过闭包，这看起来可能有点复杂。只需要想“我们传递了两个参数：一个是`i32`，一个是函数”就行。

下面，让我们看看`twice`是如何定义的：
```rust
fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {
```
`twice`有两个参数，`x`和`f`。这是它为什么我们调用它时传递两个参数。`x`是一个`i32`，我们已经很熟悉了。`f`是一个函数，不过它需要一个`i32`并返回一个`i32`。这是`Fn(i32) -> i32`类型的`F`的需要。现在`F`代表任何需要一个`i32`和返回一个`i32`的函数。

这可以是我们见过最复杂的函数标识了！多看几次直到你知道怎么用它了为止。这需要一些小的实践，然后就简单了。好消息是这样传递闭包时是非常有效率的。在编译时拥有所有这些类型信息的话编译器可以做灰常神奇的事。

最后，`twice`也返回一个`i32`。

让我们看看`twice`函数体：
```rust
fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {
  f(x) + f(x)
}
```
因为我们的闭包叫做`f`，我们可以像之前调用闭包那样调用它们，然后我们给它们每个传递一个`x`，因为我们的函数叫做`twice`。

如果你计算一下，`(5 * 5) + (5 * 5) == 50`，这就是我们得到的输出。

多耍耍这些内容直到你熟悉它们。Rust的标准库在合适的地方大量使用了闭包，所以你也应该多使用这个技术。

如果我们不想给`square`一个名字，我们也可以内联的定义它。这个例子跟上面是一样的：
```rust
fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {
    f(x) + f(x)
}

fn main() {
    twice(5, |x: i32| { x * x }); // evaluates to 50
}
```
你可以在任何用闭包的地方使用一个命名函数。上面例子的另一种写法：
```rust
fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {
    f(x) + f(x)
}

fn square(x: i32) -> i32 { x * x }

fn main() {
    twice(5, square); // evaluates to 50
}
```
这种写法并不是特别常见，不过偶尔也是有用的。

在我们继续之前，让我们看看接收两个闭包的函数。
```rust
fn compose<F, G>(x: i32, f: F, g: G) -> i32
    where F: Fn(i32) -> i32, G: Fn(i32) -> i32 {
    g(f(x))
}

fn main() {
    compose(5,
            |n: i32| { n + 42 },
            |n: i32| { n * 2 }); // evaluates to 94
}
```
你可用会问了：为什么我们要引入两个类型变量`F`和`G`？很明显，`f`和`g`有相同的标记：`Fn(i32) -> i32`。

这是因为在Rust中每个闭包都有自己独特的类型。所以，不仅不同标记的闭包有不同的类型，相同标记的不同闭包也有不同的类型。

你可以这样理解：闭包的行为是它类型的一部分。因此，对两个闭包使用一个类型标记将会导致只接受第一个闭包，拒绝第二个。因为不同类型的第二个闭包不允许它表现为与第一个类型参数一样的类型。我们承认这个问题，所以使用了`F`和`G`两个类型参数。

这也引入了`where`分句，它允许我们更灵活的描述类型参数。

这就是你了解闭包所需要的一切！ 闭包最开始有点奇怪，不过一旦你熟悉它了，你会在其它语言中想念它的。向其它函数传递函数异常强大，如你将在接下来关于迭代器这一章将看到的。
