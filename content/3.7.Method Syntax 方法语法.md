# 方法语法
函数是伟大的，不过如果你在一些数据上调用了一堆函数，这将是令人尴尬的。
考虑下面代码：
```
baz(bar(foo(x)));
```
我们可以从左向右阅读，我们会看到“baz bar foo”。不过这不是函数被调用的顺序，调用应该是从内向外的：“foo bar baz”。如果能这么做不是更好吗？
```
x.foo().bar().baz();
```
幸运的是，正如对上面那个问题的猜测，你可以！Rust通过`impl`关键字提供了使用*方法调用语法*（*method call syntax*）。

## 方法调用
这是它如何工作的：
```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

fn main() {
    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };
    println!("{}", c.area());
}
```
这会打印`12.566371`。

我们创建了一个代表圆的结构体。我们写了一个`impl`块，并且在里面定义了一个方法，`area`。方法的第一参数比较特殊，`&self`。它有3种变体：`self`，`&self`和`&mut self`。你可以认为这第一个参数就是`x.foo()`中的`x`。这3种变体对应`x`可能的3种类型：`self`如果只是栈上的一个值，`&self`如果是一个引用，然后`&mut self`如果是一个可变引用。我们应该默认使用`&self`，因为它最常见。这是一个三种变体的例子：
```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn reference(&self) {
       println!("taking self by reference!"); 
    }

    fn mutable_reference(&mut self) {
       println!("taking self by mutable reference!"); 
    }

    fn takes_ownership(self) {
       println!("taking ownership of self!"); 
    }
}
```
最后，你可能还记得，一个圆的面积是`π*r²`。因为我们向`area`传递了`&self`参数，我们可以像任何其它参数那样使用它。因为我们知道它是一个`Circle`，我们可以像处理其它结构体一样访问`radius`。导入`π`再进行一些乘法，我们就有了面积。

## 链式方法调用（Chaining method calls）
