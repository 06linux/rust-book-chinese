# 复合数据类型
像许多其它语言一样，Rust有很多不同的内建数据类型。我们已经处理过简单的整形和字符串，不过接下来，让我们了解一些复杂的储存数据的方法。

## 元组（Tuples）
我们讨论的第一个复合数据类型是*元组*（*tuples*）。元组是固定大小的有序列表。如下：
```rust
let x = (1, "hello");
```
这是一个长度为2的元组，有括号和逗号组成。下面也是同样的元组，不过注明了数据类型：
```rust
let x: (i32, &str) = (1, "hello");
```
如你所见，元组的类型跟元组看起来很像，只不过类型取代的值的位置。细心的读者可能会注意到元组是异质的：这个元组中有一个`i32`和一个`&str`。你不久前应该见过`&str`作为一个类型，我们稍后叫讨论字符串的详细内容。在系统编程语言中，字符串要比其它语言中来的复杂。现在，可以认为`&str`是一个*字符串片段*（*string slice*），我们马上会讲到它。

你可以通过一个*解构let*（*destructuring let*）访问元组中的字段。下面是一个例子：
```rust
let (x, y, z) = (1, 2, 3);

println!("x is {}", x);
```
还记得我曾经说过`let`语句的左侧不仅仅是是一个绑定吗？这就是证据。我们可以在`let`左侧写一个模式，如果它能匹配右侧的话，我们可以一次写多个绑定。这种情况下，`let`“解构”或“拆开”了元组，并分成了三个绑定。

这是一个灰常强力的模式，我们后面会经常看到它。

不解构元组，我们也可以做很多事。你一个把一个元组赋值给另一个，如果它们含有有相同的类型和数量。当它们有相同数量时，它们也有一样的长度。
```rust
let mut x = (1, 2); // x: (i32, i32)
let y = (2, 3); // y: (i32, i32)

x = y;
```
你也可以用`==`检查它们是否相等。同样，被比较的元组必须有相同的类型代码才能编译。
```rust
let x = (1, 2, 3);
let y = (2, 2, 4);

if x == y {
    println!("yes");
} else {
    println!("no");
}
```
这回打印`no`，因为有些值并不相等。

注意检查相等时值的顺序将被考虑，所以下面的例子也会打印`no`。
```rust
let x = (1, 2, 3);
let y = (2, 1, 3);

if x == y {
    println!("yes");
} else {
    println!("no");
}
```
元组的另一个作用是你可以让函数返回多个值：
```rust
fn next_two(x: i32) -> (i32, i32) { (x + 1, x + 2) }

fn main() {
    let (x, y) = next_two(5);
    println!("x, y = {}, {}", x, y);
}
```
即使Rust函数只能返回一个值，元组确实是一个值，它只是碰巧由多个值组成。在这个例子中，你可以看到我们是如何拆开函数返回值的。

元组是一个非常简单的数据结构，而通常也不是你需要的。让我们见识一下它的大哥，结构体。

## 结构体（Structs）
就想元组一样，结构是另一种形式的*记录类型*（*record type*）。不过这有个区别：结构体的每个元素都有一个名字，元素叫做*字段*或*成员*。看看下面的代码：
```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let origin = Point { x: 0, y: 0 }; // origin: Point

    println!("The origin is at ({}, {})", origin.x, origin.y);
}
```
这里有许多细节，让我们分开说。我们使用了`struct`关键字后跟名字来定义了一个结构体。根据传统，结构体使用大写字母开头并且使用驼峰命名法：`PointInSpace`而不要写成`Point_In_Space`。

想往常一样我们用`let`创建了一个结构体的实例，不过我们用`key: value`语法设置了每个字段。这里顺序不必和声明的时候一致。

最后，因为每个字段都有名字，我们可以访问字段通过圆点记法：`origin.x`。

结构体中的值默认是不可变的，就像Rust中其它的绑定一样。使用`mut`使其可变：
```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let mut point = Point { x: 0, y: 0 };

    point.x = 5;

    println!("The point is at ({}, {})", point.x, point.y);
}
```
上面的代码会打印`The point is at (5, 0)`。

## 元组结构体和新类型（Tuple Structs and Newtypes）
Rust有一个叫做*元组结构体*（*tuple struct*）的类型，它就像一个元组和结构体的混合体。元组结构体确实有一个名字，不过它的字段没有：
```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);
```
这两个是不会相等的，即使它们有一模一样的值：
```rust
let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
```
使用结构体几乎总是好于使用元组结构体。我们可以这样重写`Color`和`Point`：
```rust
struct Color {
    red: i32,
    blue: i32,
    green: i32,
}

struct Point {
    x: i32,
    y: i32,
    z: i32,
}
```
现在，我们有了名字，而不是位置。好的名字是很重要的，使用结构体，我们就可以设置名字。

不过有种情况元组结构体非常有用，就是当元组结构体只有一个元素时。我们管它叫*新类型*（*newtype*），因为你创建了一个与元素相似的类型：
```rust
struct Inches(i32);

let length = Inches(10);

let Inches(integer_length) = length;
println!("length is {} inches", integer_length);
```
如你所见，你可以通过一个解构`let`来提取内部的整形，就像我们在讲元组时说的那样，`let Inches(integer_length)`给`integer_length`赋值为`10`。
