# 复合数据类型
像许多其它语言一样，Rust有很多不同的内建数据类型。我们已经处理过简单的整形和字符串，不过接下来，让我们了解一些复杂的储存数据的方法。

## 元组（Tuples）
我们讨论的第一个复合数据类型是*元组*（*tuples*）。元组是固定大小的有序列表。如下：
```rust
let x = (1, "hello");
```
这是一个长度为2的元组，有括号和逗号组成。下面也是同样的元组，不过注明了数据类型：
```rust
let x: (i32, &str) = (1, "hello");
```
如你所见，元组的类型跟元组看起来很像，只不过类型取代的值的位置。细心的读者可能会注意到元组是异质的：这个元组中有一个`i32`和一个`&str`。你不久前应该见过`&str`作为一个类型，我们稍后叫讨论字符串的详细内容。在系统编程语言中，字符串要比其它语言中来的复杂。现在，可以认为`&str`是一个*字符串片段*（*string slice*），我们马上会讲到它。

你可以通过一个*解构let*（*destructuring let*）访问元组中的字段。下面是一个例子：
```rust
let (x, y, z) = (1, 2, 3);

println!("x is {}", x);
```
还记得我曾经说过`let`语句的左侧不仅仅是是一个绑定吗？这就是证据。我们可以在`let`左侧写一个模式，如果它能匹配右侧的话，我们可以一次写多个绑定。这种情况下，`let`“解构”或“拆开”了元组，并分成了三个绑定。

这是一个灰常强力的模式，我们后面会经常看到它。

不解构元组，我们也可以做很多事。你一个把一个元组赋值给另一个，如果它们含有有相同的类型和数量。当它们有相同数量时，它们也有一样的长度。
```rust
let mut x = (1, 2); // x: (i32, i32)
let y = (2, 3); // y: (i32, i32)

x = y;
```
你也可以用`==`检查它们是否相等。同样，被比较的元组必须有相同的类型代码才能编译。
```rust
let x = (1, 2, 3);
let y = (2, 2, 4);

if x == y {
    println!("yes");
} else {
    println!("no");
}
```
这回打印`no`，因为有些值并不相等。

注意检查相等时值的顺序将被考虑，所以下面的例子也会打印`no`。
```rust
let x = (1, 2, 3);
let y = (2, 1, 3);

if x == y {
    println!("yes");
} else {
    println!("no");
}
```
元组的另一个作用是你可以让函数返回多个值：
```rust
fn next_two(x: i32) -> (i32, i32) { (x + 1, x + 2) }

fn main() {
    let (x, y) = next_two(5);
    println!("x, y = {}, {}", x, y);
}
```
即使Rust函数只能返回一个值，元组确实是一个值，它只是碰巧由多个值组成。在这个例子中，你可以看到我们是如何拆开函数返回值的。

元组是一个非常简单的数据结构，而通常也不是你需要的。让我们见识一下它的大哥，结构体。

## 结构体（Structs）
就想元组一样，结构是另一种形式的*记录类型*（*record type*）。不过这有个区别：结构体的每个元素都有一个名字，元素叫做*字段*或*成员*。看看下面的代码：
```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let origin = Point { x: 0, y: 0 }; // origin: Point

    println!("The origin is at ({}, {})", origin.x, origin.y);
}
```
这里有许多细节，让我们分开说。我们使用了`struct`关键字后跟名字来定义了一个结构体。根据传统，结构体使用大写字母开头并且使用驼峰命名法：`PointInSpace`而不要写成`Point_In_Space`。


