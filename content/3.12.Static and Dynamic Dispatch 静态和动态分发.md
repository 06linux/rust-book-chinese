# 静态和动态分发
当涉及到多态的代码时，我们需要一个机制来决定哪个具体的版本应该得到执行。这叫做“分发”。大体上有两种形式的分发：静态分发和动态分发。虽然Rust喜欢静态分发，不过它也提供了一个叫做“特性对象”的机制来支持动态分发。

## 背景
在本章接下来的内容中，我们需要一个特性和一些实现。让我们来创建一个简单的`Foo`。它有一个返回一个`String`的方法。
```rust
trait Foo {
    fn method(&self) -> String;
}
```
我们也在`u8`和`String`上实现了这个特性：
```rust
impl Foo for u8 {
    fn method(&self) -> String { format!("u8: {}", *self) }
}

impl Foo for String {
    fn method(&self) -> String { format!("string: {}", *self) }
}
```

## 静态分发
我们可以使用特性限制来进行静态分发：
```rust
fn do_something<T: Foo>(x: T) {
    x.method();
}

fn main() {
    let x = 5u8;
    let y = "Hello".to_string();

    do_something(x);
    do_something(y);
}
```
在这里Rust用“单态”来进行静态分发。这意味着Rust会为`u8`和`String`分别创建一个特殊版本的的`do_something()`，然后将调用替换为这些特殊函数。也就是说，Rust生成了一些像这样的函数：
```rust
fn do_something_u8(x: u8) {
    x.method();
}

fn do_something_string(x: String) {
    x.method();
}

fn main() {
    let x = 5u8;
    let y = "Hello".to_string();

    do_something_u8(x);
    do_something_string(y);
}
```
这有一个很牛的好处：静态分发允许函数被内联调用，因为调用者在编译时就知道它，并且内联是好的优化的关键。静态分发是很快的，不过也有它的权衡之处：“代码膨胀”，因为对于每个类型都会有多份同样函数的拷贝存在。

此外，编译器也不是完美的并且“优化”后的代码可能更慢。例如，过度的函数内联会是指令缓存膨胀（缓存控制着我们周围的一切）。这也是为何要谨慎使用`#[inline]`和`#[inline(always)]`的部分原因，另外一个使用动态分发的原因是有时它更有效率。

然而，常规情况下静态分发更有效率，并且我们总是可以写一个小的静态分发的封装函数来进行动态分发，不过反过来不行，这就是说静态调用更加灵活。因为这个原因标准库尽可能的使用了静态分发。

## 动态分发
Rust通过一个叫做“特性对象”的功能提供动态分发。特性对象，就像`&Foo`或`Box<Foo>`，是一些储存了实现了给定特性的*任意*类型的一个值的对象，它的具体类型只能在运行时才能确定。特性的方法可以通过一个特殊的函数指针的记录（由编译器创建和管理）在特性对象上调用。

一个使用特性对象的函数并没有为每个实现了`Foo`的类型专门生成函数：它生成了一份拷贝，一般（但不总是）会减少代码膨胀。然而，这回带来使用更慢的虚函数调用的开销，也会有效的阻止任何内联和相关的优化的进行。

特性对象既简单又复杂：
