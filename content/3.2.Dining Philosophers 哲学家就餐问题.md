# 哲学家就餐问题
作为我们的第二个项目，让我们看看一个经典的并发问题。它叫做“进餐（ji）的哲学家”。它最初由Dijkstra于1965年（网上说1971年←_←）提出，不过我们会使用Tony Hoare写于1985年的[这篇论文](http://www.usingcsp.com/cspbook.pdf)的版本

> 在远古时代，一个富有的慈善家捐赠了一个学院来为5名知名的哲学家提供住处。每个哲学家都有一个房间来进行他专业的思考活动；这也有一个共用的餐厅，布置了一个圆桌，周围放着5把椅子，每一把都标出了坐在这的哲学家的名字。哲学家们按逆时针顺序围绕桌子做下。每个哲学家的左手边放着一个金叉子，而在桌子中间有一大碗意大利面，它会不时的被补充。哲学家期望用他大部分的时间思考；不过当他饿了的时候，他走向餐厅，坐在它自己的椅子上，拿起他左手边自己的叉子，然后把它插进意大利面。不过乱成一团的意大利面需要第二把叉子才能吃到嘴里。因此哲学家不得不拿起他右手边的叉子。当他吃完了他会放下两把叉子，从椅子上起来，并继续思考。当然，一把叉子一次同时只能被一名哲学家使用。如果其他哲学家需要它，他必须等待直到叉子再次可用。

这个经典的问题展示了一些不同的并发元素。原因是事实上实现它需要一些技巧：一个简单的实现可能会死锁。例如，让我们考虑一个可能解决这个问题的简单算法：

1. 一个哲学家拿起左手边的叉子
2. 他接着拿起右手边的叉子
3. 他吃
4. 他返回叉子

现在，让我们想象一下事件的序列：

1. 哲学家1开始算法，拿起他左手边的叉子
2. 哲学家2开始算法，拿起他左手边的叉子
3. 哲学家3开始算法，拿起他左手边的叉子
4. 哲学家4开始算法，拿起他左手边的叉子
5. 哲学家5开始算法，拿起他左手边的叉子
6. 。。。？所有的叉子都被拿走了，不过没人在吃（意大利面）！

有不同方法可以解决这个问题。在教程中我们用我们自己的解决办法。现在，让我们自己来为问题建模。我将从哲学家开始：

```rust
struct Philosopher {
    name: String,
}

impl Philosopher {
    fn new(name: &str) -> Philosopher {
        Philosopher {
            name: name.to_string(),
        }
    }
}

fn main() {
    let p1 = Philosopher::new("Baruch Spinoza");
    let p2 = Philosopher::new("Gilles Deleuze");
    let p3 = Philosopher::new("Karl Marx");
    let p4 = Philosopher::new("Friedrich Nietzsche");
    let p5 = Philosopher::new("Michel Foucault");
}
```

这里，我们创建了一个[`struct`][struct]来代表一个哲学家。目前，我们只需要一个名字。我们选择
