# 哲学家就餐问题
作为我们的第二个项目，让我们看看一个经典的并发问题。它叫做“进餐（ji）的哲学家”。它最初由Dijkstra于1965年（网上说1971年←_←）提出，不过我们会使用Tony Hoare写于1985年的[这篇论文](http://www.usingcsp.com/cspbook.pdf)的版本

> 在远古时代，一个富有的慈善家捐赠了一个学院来为5名知名的哲学家提供住处。每个哲学家都有一个房间来进行他专业的思考活动；这也有一个共用的餐厅，布置了一个圆桌，周围放着5把椅子，每一把都标出了坐在这的哲学家的名字。哲学家们按逆时针顺序围绕桌子做下。每个哲学家的左手边放着一个金叉子，而在桌子中间有一大碗意大利面，它会不时的被补充。哲学家期望用他大部分的时间思考；不过当他饿了的时候，他走向餐厅，坐在它自己的椅子上，拿起他左手边自己的叉子，然后把它插进意大利面。不过乱成一团的意大利面需要第二把叉子才能吃到嘴里。因此哲学家不得不拿起他右手边的叉子。当他吃完了他会放下两把叉子，从椅子上起来，并继续思考。当然，一把叉子一次同时只能被一名哲学家使用。如果其他哲学家需要它，他必须等待直到叉子再次可用。

这个经典的问题展示了一些不同的并发元素。原因是事实上实现它需要一些技巧：一个简单的实现可能会死锁。例如，让我们考虑一个可能解决这个问题的简单算法：

1. 一个哲学家拿起左手边的叉子
2. 他接着拿起右手边的叉子
3. 他吃
4. 他返回叉子

现在，让我们想象一下事件的序列：

1. 哲学家1开始算法，拿起他左手边的叉子
2. 哲学家2开始算法，拿起他左手边的叉子
3. 哲学家3开始算法，拿起他左手边的叉子
4. 哲学家4开始算法，拿起他左手边的叉子
5. 哲学家5开始算法，拿起他左手边的叉子
6. 。。。？所有的叉子都被拿走了，不过没人在吃（意大利面）！

有不同方法可以解决这个问题。在教程中我们用我们自己的解决办法。现在，让我们自己来为问题建模。我将从哲学家开始：

```rust
struct Philosopher {
    name: String,
}

impl Philosopher {
    fn new(name: &str) -> Philosopher {
        Philosopher {
            name: name.to_string(),
        }
    }
}

fn main() {
    let p1 = Philosopher::new("Baruch Spinoza");
    let p2 = Philosopher::new("Gilles Deleuze");
    let p3 = Philosopher::new("Karl Marx");
    let p4 = Philosopher::new("Friedrich Nietzsche");
    let p5 = Philosopher::new("Michel Foucault");
}
```

这里，我们创建了一个[`struct`][struct]来代表一个哲学家。目前，我们只需要一个名字。我们选择[`String`][string]类型作为名字，而不是`&str`。通常来说，处理一个拥有它自己数据的类型要比使用引用的数据来的简单。

让我们继续：

```rust
impl Philosopher {
    fn new(name: &str) -> Philosopher {
        Philosopher {
            name: name.to_string(),
        }
    }
}
```

`impl`块让我们在`Philosopher`上定义方法。在这个例子中，我们定义了一个叫做`new`的“关联函数”。第一行看起来像这样：

```rust
fn new(name: &str) -> Philosopher {
```

我们获取了一个参数，`name`，`&str`类型的。这是另一个字符串的引用。它返回了一个我们`Philosopher`结构体的实例。

```rust
Philosopher {
    name: name.to_string(),
}
```

这创建了一个新的`Philosopher`，并把它的`name`设置为我们的`name`参数。不仅仅是参数自身，虽然，因为我们在它上面调用了`.to_string()`。这将创建一个我们`&str`指向的字符串的拷贝，并给我们一个新的`String`，它是我们`Philosopher`的`name`字段的类型。

为什么不直接接受一个`String`呢？它更方便调用。如果我们获取一个`String`，而我们的调用者有一个`&str`，它就不得不自己调用这个方法。这个灵活性的缺点是我们*总是*生成了一个拷贝。对于我们这个小程序，这并不是特别的重要，因为我们知道我们只会用短小的字符串。

你要注意到的最后一件事：我们刚刚定义了一个`Philosopher`，不过好像并没有对它做什么。Rust是一个“基于表达式”的语言，它意味着Rust中几乎所有的东西都是一个表达式并返回一个值。这对函数也适用，最后的表达式是自动返回的。因为我们创建了一个新的`Philosopher`作为这个函数最后的表达式，我们最终返回了它。

这个名字，`new()`，在Rust中并没有什么特殊性。不过它是创建一个结构体新实例的函数的传统名称。在我们讨论为什么之前，让我们再看看`main()`：

```rust
fn main() {
    let p1 = Philosopher::new("Baruch Spinoza");
    let p2 = Philosopher::new("Gilles Deleuze");
    let p3 = Philosopher::new("Karl Marx");
    let p4 = Philosopher::new("Friedrich Nietzsche");
    let p5 = Philosopher::new("Michel Foucault");
}
```

这里，我们创建了5个新哲学家的变量绑定。这是我最崇拜的5个，不过你可以替换为任何你想要的。如果我们*没有*定义`new()`函数，它将看起来像这样：

```rust
fn main() {
    let p1 = Philosopher { name: "Baruch Spinoza".to_string() };
    let p2 = Philosopher { name: "Gilles Deleuze".to_string() };
    let p3 = Philosopher { name: "Karl Marx".to_string() };
    let p4 = Philosopher { name: "Friedrich Nietzche".to_string() };
    let p5 = Philosopher { name: "Michel Foucault".to_string() };
}
```

这看起来更乱。使用`new`还有别的优点，不过即便在这个简单的例子，它也被证明是易于使用的。
