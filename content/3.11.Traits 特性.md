# 特性
你还记得`impl`关键字吗，曾用方法语法调用方法的那个？
```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}
```
特性也很类似，除了我们用函数标记来定义一个特性，然后为结构体实现特性。例如：
```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

trait HasArea {
    fn area(&self) -> f64;
}

impl HasArea for Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}
```
如你所见，`trait`块与`impl`看起来很像，不过我们没有定义一个函数体，只是函数标记。当我们`impl`一个特性时，我们使用`impl Trait for Item`，而不是仅仅`impl Item`。

那么只有什么重要的呢？还记得我们使用泛型`inverse`函数得到的错误吗？
```bash
error: binary operation `==` cannot be applied to type `T`
```
我们可以用特性来约束我们的泛型。考虑下这个函数，它不能编译并给出一个类似的错误：
```rust
fn print_area<T>(shape: T) {
    println!("This shape has an area of {}", shape.area());
}
```
Rust抱怨说：
```bash
fn print_area<T>(shape: T) {
    println!("This shape has an area of {}", shape.area());
}
```
因为`T`可以是任何类型，我们不能确定它实现了`area`方法。不过我们可以在泛型`T`添加一个*特性约束*（*trait constraint*），来确保它实现了对应方法：
```rust
fn print_area<T: HasArea>(shape: T) {
    println!("This shape has an area of {}", shape.area());
}
```
`<T: HasArea>`是指`any type that implements the HasArea trait`（任何实现了HasArea特性的类型）。因为特性定义了函数类型标记，我们可以确定任何实现`HasArea`将会拥有一个`.area()`方法。

这是一个扩展的例子演示它如何工作：
```rust
trait HasArea {
    fn area(&self) -> f64;
}

struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl HasArea for Circle {
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

struct Square {
    x: f64,
    y: f64,
    side: f64,
}

impl HasArea for Square {
    fn area(&self) -> f64 {
        self.side * self.side
    }
}

fn print_area<T: HasArea>(shape: T) {
    println!("This shape has an area of {}", shape.area());
}

fn main() {
    let c = Circle {
        x: 0.0f64,
        y: 0.0f64,
        radius: 1.0f64,
    };

    let s = Square {
        x: 0.0f64,
        y: 0.0f64,
        side: 1.0f64,
    };

    print_area(c);
    print_area(s);
}
```
这个程序会输出：
```bash
This shape has an area of 3.141593
This shape has an area of 1
```
如你所见，`print_area`现在是泛型的了，并且确保我们传递了正确的类型。如果我们传递了错误的类型：
```rust
print_area(5);
```
我们会得到一个编译时错误：
```bash
error: failed to find an implementation of trait main::HasArea for int
```
目前为止，我们只在结构体上添加特性实现，不过你为任何类型实现一个特性。所以技术上讲，你可以在`i32`上实现`HasArea`：
```rust
trait HasArea {
    fn area(&self) -> f64;
}

impl HasArea for i32 {
    fn area(&self) -> f64 {
        println!("this is silly");

        *self as f64
    }
}

5.area();
```
在基本类型上实现方法被认为是不好的设计，即便这是可以的。

这看起来有点像狂野西部，不过这还有两个限制来避免情况失去控制。第一，特性必须在你想要使用它的作用域中被`use`。所以例如，下面的代码不能工作：
```rust
mod shapes {
    use std::f64::consts;

    trait HasArea {
        fn area(&self) -> f64;
    }

    struct Circle {
        x: f64,
        y: f64,
        radius: f64,
    }

    impl HasArea for Circle {
        fn area(&self) -> f64 {
            consts::PI * (self.radius * self.radius)
        }
    }
}

fn main() {
    let c = shapes::Circle {
        x: 0.0f64,
        y: 0.0f64,
        radius: 1.0f64,
    };

    println!("{}", c.area());
}
```
现在我们把
