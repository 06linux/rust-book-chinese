# 模式
模式在Rust中灰常常见。我们在[变量绑定](http://doc.rust-lang.org/nightly/book/variable-bindings.html)，[匹配语句](http://doc.rust-lang.org/nightly/book/match.html)和其它一些地方使用它们。让我们开始一个快速的关于模式可以干什么的教程！

一个快速回顾：你可以直接匹配常量，并且`_`作为“任意”类型：

```rust
let x = 1;

match x {
    1 => println!("one"),
    2 => println!("two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

## 多重模式
你可以使用`|`匹配多个模式：

```rust
let x = 1;

match x {
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
}
```

## 范围
你可以用`...`匹配一个范围的值：

```rust
let x = 1;

match x {
    1 ... 5 => println!("one through five"),
    _ => println!("anything"),
}
```

范围经常用在整数和单个字符上。

## 绑定
如果你匹配多个值，通过`|`或`...`，你可以用`@`给这个值绑定一个名字：
```rust
let x = 1;

match x {
    e @ 1 ... 5 => println!("got a range element {}", e),
    _ => println!("anything"),
}
```

## 忽略变量
如果你匹配一个带有变体的枚举，你可以用`..`来忽略变体的值和类型：

```rust
enum OptionalInt {
    Value(i32),
    Missing,
}

let x = OptionalInt::Value(5);

match x {
    OptionalInt::Value(..) => println!("Got an int!"),
    OptionalInt::Missing => println!("No such luck."),
}
```

## 守卫（Guards）
你可以用`if`来引入*匹配守卫*（*match guards*）：

```rust
enum OptionalInt {
    Value(i32),
    Missing,
}

let x = OptionalInt::Value(5);

match x {
    OptionalInt::Value(i) if i > 5 => println!("Got an int bigger than five!"),
    OptionalInt::Value(..) => println!("Got an int!"),
    OptionalInt::Missing => println!("No such luck."),
}
```

## `ref`和`ref mut`
如果你想要一个引用，使用`ref`关键字：

```rust
let x = 5;

match x {
    ref r => println!("Got a reference to {}", r),
}
```

这里，`match`中的`r`是`&i32`类型的。换句话说，`ref`关键字创建了一个在模式中使用的引用。如果你需要一个可变引用，`ref mut`同样可以做到：

```rust
let mut x = 5;

match x {
    ref mut mr => println!("Got a mutable reference to {}", mr),
}
```

## 解构
如果你有一个结构体，你可以在模式中解构它：

```rust
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x: x, y: y } => println!("({},{})", x, y),
}
```

如果你只关心部分值，我们不需要给它们都命名：

```rust
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x: x, .. } => println!("x is {}", x),
}
```

你可以对任何成员进行这样的匹配，不仅仅是第一个：

```rust
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { y: y, .. } => println!("y is {}", y),
}
```

这种“解构”行为可以用在任何复合数据类型上，例如[元组](http://doc.rust-lang.org/nightly/book/primitive-types.html#tuples)和[枚举](http://doc.rust-lang.org/nightly/book/enums.html)

## 混合与匹配
(口哨)！这里有很多种匹配的方法，它们都能进行组合匹配，根据你想干什么：
```rust
match x {
    Foo { x: Some(ref name), y: None } => ...
}
```
模式灰常强大。好好使用它们。
