# 测试
> Program testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence.

> Edsger W. Dijkstra, "The Humble Programmer" (1972)

> 软件测试是证明bug存在的有效方法，而证明它们不存在时则显得令人绝望的不足。

> Edsger W. Dijkstra，【谦卑的程序员】（1972）

让我们讨论一下如何测试Rust代码。在这里我们不会讨论什么是测试Rust代码的正确方法。这里有很多关于写测试好坏方法的流派。所有的这些途径都使用相同的基本工具，所以我们会想你展示他们的语法。

## 测试属性（The test attribute）
简单的说，测试是一个标记为`test`属性的函数。让我们用Cargo来创建一个叫`adder`的项目：
```rust
$ cargo new adder
$ cd adder
```
在你创建一个新项目时Cargo会自动生成一个简单的测试。下面是`src/lib.rs`的内容：
```rust
#[test]
fn it_works() {
}
```
注意这个`#[test]`。这个属性表明这是一个测试函数。它现在没有函数体。它肯定能编译通过！让我们用`cargo test`运行测试：
```bash
$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
```
Cargo编译和运行了我们的测试。这里有两部分输出：一个是我们写的测试，另一个是文档测试。我们稍后再讨论这些。现在，看看这行：
```bash
test it_works ... ok
```
注意那个`it_works`。这是我们函数的名字：
```rust
fn it_works() {
```
然后我们有一个总结行：
```bash
test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
```
那么为啥我们这个啥都没干的测试通过了呢？任何没有`panic!`的测试通过，`panic!`的测试失败。让我们的测试失败：
```rust
#[test]
fn it_works() {
    assert!(false);
}
```
`assert!`是Rust提供的一个宏，它接受一个参数：如果参数是`true`，啥也不会发生。如果参数是`false`，它会`panic!`。让我们再次运行我们的测试：
```bash
$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... FAILED

failures:

---- it_works stdout ----
        thread 'it_works' panicked at 'assertion failed: false', /home/steve/tmp/adder/src/lib.rs:3



failures:
    it_works

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured

thread '<main>' panicked at 'Some tests failed', /home/steve/src/rust/src/libtest/lib.rs:247
```
Rust指出我们的测试失败了：
```bash
test it_works ... FAILED
```
这反映在了总结行上：
```bash
test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
```
我们也得到了一个非0的状态值：
```bash
$ echo $?
101
```
这在你想把`cargo test`集成进其它工具是非常有用。

我们可以使用另一个属性反转我们的失败的测试：`should_fail`：
```rust
#[test]
#[should_fail]
fn it_works() {
    assert!(false);
}
```
现在即使我们`panic!`了测试也会通过，并且如果我们的测试通过了则会失败。让我试一下：
```bash
$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
```
Rust提供了另一个宏，`assert_eq!`用来比较两个参数：
```rust
#[test]
#[should_fail]
fn it_works() {
    assert_eq!("Hello", "world");
}
```
那个测试通过了吗？因为那个`should_fail`属性，它通过了：
```
$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
```
`should_fail`测试是脆弱的，因为很难保证测试是否会因什么不可预测原因并未失败。为了解决这个问题，`should_fail`属性可以添加一个可选的`expected`参数。这个参数可以确保失败信息中包含我们提供的文字。下面是我们例子的一个更安全的版本：
```rust
#[test]
#[should_fail(expected = "assertion failed")]
fn it_works() {
    assert_eq!("Hello", "world");
}
```
这就是全部的基础内容！让我们写一个“真实”的测试：
```rust
pub fn add_two(a: i32) -> i32 {
    a + 2
}

#[test]
fn it_works() {
    assert_eq!(4, add_two(2));
}
```
`assert_eq!`是非常常见的；用已知的参数调用一些函数然后与期望的输出进行比较。
