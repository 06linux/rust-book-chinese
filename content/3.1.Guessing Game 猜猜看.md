# 猜猜看
作为我们的第一个项目，我们来实现一个经典新手编程问题：猜猜看游戏。它是这么工作的：我们的程序将会随机生成一个1到100之间的随机数。它接着会提示我们猜一个数。当我们猜了一个数之后，它会告诉我们是大了还是小了。当我们猜对了，它会祝贺我们。听起来如何？

## 准备
我们准备一个新项目。进入到你的项目目录。还记得我们曾经创建我们`hello_world`的项目目录和`Cargo.toml`文件吗？Cargo有一个命令来为我们做这些。让我们试试：

```bash
$ cd ~/projects
$ cargo new guessing_game --bin
$ cd guessing_game
```

我们将项目名字传递给`cargo new`，然后用了`--bin`标记，因为我们要创建一个二进制文件，而不是一个库文件。

查看生成的`Cargo.toml`文件：

```toml
[package]

name = "guessing_game"
version = "0.0.1"
authors = ["Your Name <you@example.com>"]
```

Cargo从环境变量中获取这些信息。如果这不对，赶紧修改它。

最后，Cargo为我们生成了应给“Hello, world!”。查看`src/main.rs`文件：

```rust
fn main() {
    println!("Hello, world!")
}
```

让我们编译Cargo为我们生成的项目：

```bash
$ cargo build
   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)
```

很好，再次打开你的`src/main.rs`文件。我们会将所有代码写在这个文件里。稍后我们会讲到多文件项目。

在我们继续之前，让我们再告诉你一个新的Cargo命令：`run`。`cargo run`跟`cargo build`类似，并且还会运行我们刚生成的可执行文件。试试它：

```bash
$ cargo run
   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Hello, world!
```

很好！`run`命令在我们需要快速重复运行一个项目是非常方便。我们的游戏就是这么一个项目，在我们添加新内容之前我们需要经常快速测试项目。

## 处理一次猜测
让我们开始吧！我们需要做的第一件事是让我们的玩家输入一个猜测。把这些放入你的`src/main.rs`：

```rust
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin().read_line(&mut guess)
        .ok()
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
```

这有好多东西！让我们一点一点的过一遍。

```rust
use std::io;
```

我们需要获取用户输入，并接着打印结果作为输出。为此，我们需要标准库的`io`库。Rust为所有程序只导入了很少一些东西，[‘prelude’](http://doc.rust-lang.org/nightly/std/prelude/)。如果它不在预先导入中，你将不得不直接`use`它。

```rust
fn main() {
```

就像你之前见过的，`main()`是你程序的入口点。`fn`语法声明了一个新函数，`()`表明这里没有参数，而`{`开始了函数体。因为我们不包含返回类型，它假设是`()`，一个空的[元组](http://doc.rust-lang.org/nightly/book/primitive-types.html#tuples)。

```rust
    println!("Guess the number!");

    println!("Please input your guess.");
```

我们之前学过`println!()`是一个在屏幕上打印[字符串](http://doc.rust-lang.org/nightly/book/strings.html)的[宏](http://doc.rust-lang.org/nightly/book/macros.html)。

```rust
    let mut guess = String::new();
```


现在我们遇到有意思的东西了！这一小行有很多内容。第一个我们需要注意到的是[let语句](http://doc.rust-lang.org/nightly/book/variable-bindings.html)，它用来创建“变量绑定”。它使用这个形式：

```rust
let foo = bar;
```

这回创建一个叫做`foo`的新绑定，并绑定它到`bar`这个值上。在很多语言中，这叫做一个“变量"，不过Rust的变量绑定暗藏玄机。

例如，它们默认是[不可变的](http://doc.rust-lang.org/nightly/book/mutability.html)。这时为什么我们的例子使用了`mut`：它让一个绑定可变，而不是不可变。`let`并不从左手边获取一个名字，事实上他接受一个[模式（pattern）](http://doc.rust-lang.org/nightly/book/patterns.html)。我们会在后面更多的使用模式。现在它使用起来非常简单：

```rust
let foo = 5; // immutable.
let mut bar = 5; // mutable
```

噢，同时`//`会开始一个注释，直到这行的末尾。Rust忽略[注释](http://doc.rust-lang.org/nightly/book/comments.html)中的任何内容。

那么现在我们知道了`let mut guess`会引入一个叫做`guess`的可变绑定，不过我们不得不看看`=`的右侧，它绑定的内容：`String::new()`。

`String`是一个字符串类型，由标准库提供。[String](http://doc.rust-lang.org/nightly/std/string/struct.String.html)是一个可增长的，UTF-8编码的文本。

`::new()`语法用了`::`因为它是一个特定类型的”关联函数“。这就是说，它与`String`自身关联，而不是与一个特定的`String`实例关联。一些语言管这叫一个”静态方法“。

这个函数叫做`new()`，因为它创建了一个新的，空的`String`。你会在很多类型上找到`new()`函数，因为它是创建一些类型新值的通常名称。

让我们继续：

```rust
    io::stdin().read_line(&mut guess)
        .ok()
        .expect("Failed to read line");
```

这稍微有点多！让我们一点一点来。第一行有两部分。这是第一部分：

```rust
io::stdin()
```

还记得我们如何在程序的第一行`use``std::io`的吗？现在我们调用了一个与之相关的函数。如果我们不`use std::io`，那么我们就得写成`std::io::stdin()`。

这个特殊的函数返回一个句柄到你终端的标准输入。更具体的，一个[std::io::Stdin](http://doc.rust-lang.org/nightly/std/io/struct.Stdin.html)。

下一部分将用这个句柄去获取用户输入：

```rust
.read_line(&mut guess)
```

这里，我们对我们的句柄调用了[read_line()](http://doc.rust-lang.org/nightly/std/io/struct.Stdin.html#method.read_line)方法。[方法](http://doc.rust-lang.org/nightly/book/methods.html)（404）就像关联函数，不过只在一个类型的特定实例上可用，而不是这个类型本身。我们也向`read_line()`传递了一个参数：`&mut guess`。

还记得我们上面怎么绑定`guess`的吗？我们说它是可变的。然而，`read_line`并不获取`String`作为一个参数：它获取一个`&mut String`。Rust有一个叫做[“引用”](http://doc.rust-lang.org/nightly/book/references-and-borrowing.html)的功能，它允许你对一片数据有多个引用，用它可以减少拷贝。引用是一个复杂的功能，因为Rust的一个主要卖点就是它如何安全和便捷的使用引用。然而，目前我们还不需要知道很多细节来完成我们的程序。现在，所有我们需要了解的是像`let`绑定，引用默认是不可变的。因此，我们需要写成`&mut guess`，而不是`&guess`。

为什么`read_line()`会需要一个字符串的可变引用呢？它的工作是从标准输入获取用户输入，并把它放入一个字符串。所以它用字符串作为参数，为了可以增加输入，它必须是可变的。

不过我们还未完全看完这行代码。虽然它是单独的一行代码，它是只是这个单独逻辑代码行的开头部分：

```rust
        .ok()
        .expect("Failed to read line");
```

当你用`.foo()`语法调用一个函数的时候，你可能会引入一个新行符或其它空白。这帮助我们拆分长的行。我们*可以*这么干：

```rust
    io::stdin().read_line(&mut guess).ok().expect("failed to read line");
```

不过这样会难以阅读。所以我们把它分开，3行对应3个方法调用。我们已经谈论过了`read_line()`，不过`ok()`和`expect()`呢？好吧，我们已经提到过`read_line()`将用户输入放入我们传递给它的`&mut String`中。不过他也返回一个值：在这个例子中，一个[io::Result](http://doc.rust-lang.org/nightly/std/io/type.Result.html)。Rust的标准库中有很多叫做`Result`的类型：一个泛型[Result](http://doc.rust-lang.org/nightly/std/result/enum.Result.html)，然后是子库的特殊版本，例如`io::Result`。

这个`Result`类型的作用是编码错误处理信息。`Result`类型的值，像任何（其它）类型，有定义在其上的方法。在这个例子中，`io::Result`有一个`ok()`方法，它说“我们想假设这个值是一个成功的值。如果不是，就抛出错误信息”。为什么要抛出错误呢？好吧，对于一个基础的程序，我们只想打印出一个通用错误，因为基本上任何问题意味着我们不能继续。[ok()方法](http://doc.rust-lang.org/nightly/std/result/enum.Result.html#method.ok)返回一个值，有另一个方法定义在其上：`expect()`。[expect()方法](http://doc.rust-lang.org/nightly/std/option/enum.Option.html#method.expect)获取调用它的值，而且如果它不是一个成功的值，[panic!](http://doc.rust-lang.org/nightly/book/error-handling.html)并带有你传递给它的信息。这样的`panic!`会使我们的程序崩溃，显示（我们传递的）信息。

如果我们去掉这两个函数调用，我们的程序会编译通过，不过我们会得到一个警告：

```rust
$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
src/main.rs:10:5: 10:39 warning: unused result which must be used,
#[warn(unused_must_use)] on by default
src/main.rs:10     io::stdin().read_line(&mut guess);
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

Rust警告我们我们并未使用`Result`的值。这个警告来自`io::Result`的一个特殊注解。Rust尝试告诉你你并未处理一个可能的错误。阻止错误的正确方法是老实编写错误处理。幸运的是，如果我们只是想如果这有一个问题就崩溃的话，我们可以用这两个小方法。如果我们想从错误中恢复什么的，我们得做点别的，不过我们会把它留给接下来的项目。

这是我们第一个例子仅剩的一行：

```rust
    println!("You guessed: {}", guess);
}
```

这打印出我们保存输入的字符串。`{}`是一个占位符，所以我们传递`guess`作为一个参数。如果我们有多个`{}`，我们应该传递多个参数：

```rust
let x = 5;
let y = 10;

println!("x and y: {} and {}", x, y);
```

简单加愉快。

不过怎么说，这只是一个观光。我们可以用`cargo run`运行我们写的：

```rust
$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
```

好的！我们的第一部分完成了：我们可以从键盘获取输入，并把它打印回去。

## 生成一个秘密数字
接下来，我们要生成一个秘密数字。Rust标准库中还未包含一个随机数功能。Rust团队确实，然而，提供了一个[`rand` crate](https://crates.io/crates/rand)。一个“包装箱”（crate）是一个Rust代码的包。我们已经构建了一个”二进制包装箱“，它是一个可执行文件。`rand`是一个”库包装箱“，它包含被认为应该被其它程序使用的代码。

使用外部包装箱是Cargo的亮点。在我们使用`rand`编写代码之前，我们需要修改我们的`Cargo.toml`。打开它，并在末尾增加这几行：

```toml
[dependencies]

rand="0.3.0"
```

`Cargo.toml`的`[dependencies]`部分就像`[package]`部分：所有之后的东西都是它的一部分，直到下一个部分开始。Cargo使用依赖部分来知晓你用的外部包装箱的依赖，和你要求的版本。在这个例子中，我们用了`0.3.0`版本。Cargo理解[语义化版本](http://semver.org/lang/zh-CN/)，它是一个编写版本号的标准。如果我们想要使用最新版本我们可以使用`*`或者我们可以使用一个范围的版本。[Cargo文档](http://doc.crates.io/crates-io.html)包含更多细节。

现在，在不修改任何我们代码的情况下，让我们构建我们的项目：

```bash
$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.8
 Downloading libc v0.1.6
   Compiling libc v0.1.6
   Compiling rand v0.3.8
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
```

（当然，你可能会看到不同的版本）

很多新的输出！现在我们有了一个外部依赖，Cargo从记录中获取了所有东西的最新版本，它们是来自[Crates.io](https://crates.io/)的一份拷贝。Crates.io是Rust生态系统中人们发表开源Rust项目供它人使用的地方。

在更新了记录后，Cargo检查我们的`[dependencies]`并下载任何我们还没有的东西。在这个例子中，虽然我们只说了我们要依赖`rand`，我们也获取了一份`libc`的拷贝。这是因为`rand`依赖`libc`工作。在下载了它们之后，它编译它们，然后接着编译我们的项目。

如果我们再次运行`cargo build`，我们会得到不同的输出：

```bash
$ cargo build
```

没错，木有输出！Cargo知道我们的项目被构建了，并且所有它的依赖也被构建了，所以没有理由再做一遍所有这一些。没有事情做，它简单的退出了。如果我们再打开`src/main.rs`，做一个无所谓的修改，然后接着再保存，我们就会看到一行：

```bash
$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
```

所以，我们告诉Cargo我们需要任何`0.3.x`版本的`rand`，并且因此它获取在本文被编写时的最新版，`v0.3.8`。不过你瞧瞧当下一周，`v0.3.9`出来了，带有一个重要的bug修改吗？虽然bug修改很重要，不过如果`0.3.9`版本包含破坏我们代码的回归呢？

这个问题的回答是现在你会在你项目目录中找到的`Cargo.lock`。当你第一次构建你的项目的时候，Cargo查明所有符合你的要求的版本，并接着把它们写到了`Cargo.lock`文件里。当你在未来构建你的项目的时候，Cargo会注意到`Cargo.lock`的存在，并接着使用指定的版本而不是再次去做查明版本的所有工作。这让你有了一个可重复的自动构建。换句话说，我们会保持在`0.3.8`直到我们显式的升级，这对任何使用我们共享的代码的人同样有效，感谢锁文件。
