# 裸指针
Rust的标准库中有一系列不同的智能指针类型，不过这有两个类型是十分特殊的。Rust的安全大多来源于编译时检查，不过裸指针并没有这样的保证，使用它们是[`unsafe`](http://doc.rust-lang.org/nightly/book/unsafe.html)的。

`*const T`和`*mut T`在Rust中被称为“裸指针”。有时当编写特定类型的




## 介绍
Rust计划在CPU和操作系统的底层细节之上提供安全的抽象，不过有时我们需要编写底层代码。本教程旨在提供一个Rust不安全子集力量与危险的概括。

Rust提供了一个`unsafe { ... }`块这种形式的安全出口，它允许程序猿绕开编译器检查并进行大范围的操作，例如：

* 解引用[裸指针](http://doc.rust-lang.org/book/unsafe.html#raw-pointers)
* 通过FFI调用函数（[由FFI教程介绍](http://doc.rust-lang.org/book/ffi.html)）
* 二进制的转换类型（`transmute`，也就是指“强制类型转换”）
* [内联汇编](http://doc.rust-lang.org/book/unsafe.html#inline-assembly)

注意在`unsafe`并没有放松对`&`声明周期的监管和对借用数据的锁定。

`unsafe`的使用代表着程序员“比编译器知道的更多”，并且因此，程序员必须非常确信他们确实比这段代码为何是有效的知道的更多。总体来说，他们应该在代码库中尽可能减少不安全代码的数量；倾向于使用最少的`unsafe`块来构建安全的接口。

> **注意**：Rust语言的底层细节仍在不断改变中，并且没有稳定性和后向兼容性的保证。特别的，可能会有不会造成编译错误，不过会导致语义改变（例如使用未定义的行为）的修改。因此，使用时需要格外小心。

## 指针
### 引用
Rust最大的功能之一是内存安全。这部分依赖于[所有权系统](http://doc.rust-lang.org/book/ownership.html)，它使得编译器可以确保每一个`&`引用总是有效的，并且，例如，从不指向被释放的内存。

对`&`的限制有巨大的优势。然而，这也限制了我们对它的使用。例如，`&`与C指针并不相同，因此并不能在外部语言接口（FFI）中作为指针使用。另外，不可变和可变引用有一些混淆和冻结的保证，作为内存安全的需要。

特别的，如果你有一个`&T`引用，那么`T`肯定不能通过这个引用或其它引用被修改。一些像`Cell`和`RefCell`的标准库类型类型，它们通过用运行时动态检查代替编译时保障来提供内部的可变性。

`&mut`有一个不同的约束：如果一个对象有一个`&mut T`指向它，那么这`&mut`引用必须是整个程序中唯一一个指向该对象的可用路径。也就是说，`&mut`不能是任何其它引用的别名。

使用`unsafe`代码来不正确的绕过和违反这些限制会导致没有定义的行为。例如，下面的包装箱创建了两个混淆的`&mut`指针，而这时无效的。
```rust
use std::mem;
let mut x: u8 = 1;

let ref_1: &mut u8 = &mut x;
let ref_2: &mut u8 = unsafe { mem::transmute(&mut *ref_1) };

// oops, ref_1 and ref_2 point to the same piece of data (x) and are
// both usable
*ref_1 = 10;
*ref_2 = 20;
```

## 裸指针
Rust提供另外两种指针类型（裸指针），写作`*const T`和`*mut T`。它们分别与C的`const T*`和`T*`类似；实际上，它们最常用的作用之一就是FFI，与外部C库交互。

与Rust语言和库提供的其它指针类型相比裸指针拥有更少的保障。例如，它

* 不能保证指向有效的内存，甚至不能保证是非空的（不像`Box`和`&`）；
* 没有任何自动清除，不像`Box`，所以需要手动管理资源；
* 是普通旧式类型，也就是说，它不移动所有权，这也不像`Box`，因此Rust编译器不能保证不出像释放后使用这种bug；
* 被认为是可发送的（如果它的内容是可发送的），因此编译器不能提供帮助确保它的使用是线程安全的；例如，你可以从两个线程中并发的访问`*mut i32`而不用同步。
* 缺少任何形式的生命周期，不像`&`，因此编译器不能判断出悬垂指针；
* 缺少关于别名的保障，除非使用`*const T`直接不允许改变，也缺少可变性的保障。

幸运的是，它有一个补偿功能：更弱的保障意味着更弱的限制。缺失的限制使得裸指针适合编写实现库中像智能指针和向量的构建模块。例如，`*`指针允许别名，使得他可以用来编写像引用计数和垃圾回收的指针这样的共享所有权类型，甚至是线程安全的共享内存类型（`Rc`和`Arc`类型都是完全用Rust实现的）。

关于裸指针有两点你需要注意（也就是说需要`unsafe { ... }`块）：
* 解引用：它可以拥有任何值：所以可能的结果包括崩溃，读取未初始化内存，释放后使用，或者正常的数据读取。
* 通过`offset`[Intrinsics](http://doc.rust-lang.org/book/unsafe.html#intrinsics)（或者`.offset`方法）的指针算术：这个intrinsic使用所谓的“界内”算术，这就是说，如果结果是在原始指针指向的对象之内（或者是结尾之后的一个字节）的这是唯一定义了的行为。

后一个假设使得编译器可以更有效的优化。就像你看到的，实际“创建”一个裸指针是不安全的，即便是把它转换为整形。

### 引用和裸指针
在运行时，指向同样一片数据的裸指针和引用有相同的表现。事实上，在安全代码中`&T`引用会隐式转换为一个`*const T`裸指针而`mut`变体也有相似的情况（这两个转换都可以显式进行，分别生成`value as *const T`和`value as *mut T`）。

反过来，把`*const`转换为`&`是不安全的。`&T`总是有效的，因此，最少裸指针`*const T`必须得指向一个有效的`T`的实例。此外，得到的指针必须满足引用的别名和可变性规则。编译器假设这些属性使用与任何引用，不过它是如何创建的，所以任何裸指针的转换都断言它们满足这些条件，程序猿*必须*保证这些。

推荐的转换方法是：

```rust
let i: u32 = 1;
// explicit cast
let p_imm: *const u32 = &i as *const u32;
let mut m: u32 = 2;
// implicit coercion
let p_mut: *mut u32 = &mut m;

unsafe {
    let ref_imm: &u32 = &*p_imm;
    let ref_mut: &mut u32 = &mut *p_mut;
}
```

`&*x`解引用风格倾向于使用`transmute`。后一种方法远比需要的强力，并且限制更严格的操作更难出错；例如，它要求`x`是一个指针（不像`transmute`）

## 使不安全变（更）安全
这里有多种方法在有不安全代码时导出安全的接口：

* 私有的保存指针（也就是说，不在公有结构体的公有字段中），这样你可以在一个地方看见和控制对指针的所有读写。
* 多使用`assert!()`：因为你不能依靠编译器或类型系统保证你的`unsafe`代码在编译时是正确的，使用`assert!()`来验证它们会在运行时正常工作。
* 为资源实现`Drop`以便通过析构函数清理，并遵循RAII（资源获取就是初始化）原则。这减少了任何手动内存管理的需要，并且确保清理总会自动运行，即便是线程恐慌的情况下。
* 确保任何储存在一个裸指针中的数据都在合适的时间被销毁。
