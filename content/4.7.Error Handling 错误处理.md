# 错误处理

> [error-handling.md](https://github.com/rust-lang/rust/blob/master/src/doc/book/error-handling.md)
> <br>
> commit e26279db48cc5510a13f0e97bde97ccd2d2a1854

就像大多数编程语言，Rust 鼓励程序猿以特定的方式处理错误。一般来讲，错误处理被分割为两个大类：异常和返回值。Rust 选择了返回值。

在这一部分，我们试图提供一个全面的 Rust 如何处理错误的解决方案。不仅如此，我们也尝试一次一点的介绍错误处理，这样当你离开时会有一个所有东西如何协调的坚实理解。

Rust 的错误处理天生是冗长而烦人的。这一部分将会探索这些坑并展示如何使用标准库来让错误处理变得准确和符合工程原理。

## 内容列表

这一部分灰常的长，大部分因为我们从最基础的和类型和组合入手，并尝试一点一点的解释 Rust 错误处理的动机。为此，对有其他类似类型系统经验的童鞋可能想要跳过一些内容。

* [基础](#the-basics)
    * [理解uunwrapping](#unwrapping-explained)
    * [`Option`类型](#the-option-type)
        * [组合`Option<T>`值](#composing-optiont-values)
    * [`Result`类型](#the-result-type)
        * [解析整型](#parsing-integers)
        * [`Result`类型别名习惯](#the-result-type-alias-idiom)
    * [小插曲：unwrapping 并不邪恶](#a-brief-interlude-unwrapping-isnt-evil)
* [处理多种错误类型](#working-with-multiple-error-types)
    * [组合`Option`和`Result`](#composing-option-and-result)
    * [组合的限制](#the-limits-of-combinators)
    * [提早返回](#early-returns)
    * [`try!`宏](#the-try-macro)
    * [定义你自己的错误类型](#defining-your-own-error-type)
* [用于错误处理的标准库 trait](#standard-library-traits-used-for-error-handling)
    * [`Error`trait](#the-error-trait)
    * [`From`trait](#the-from-trait)
    * [真正的`try!`macro](#the-real-try-macro)
    * [组合自定义错误类型](#composing-custom-error-types)
    * [给库编写者的建议](#advice-for-library-writers)
* [案例学习：一个读取人口数据的程序](#case-study-a-program-to-read-population-data)
    * [初始化](#initial-setup)
    * [参数解析](#argument-parsing)
    * [编写逻辑](#writing-the-logic)
    * [使用`Box<Error>`处理错误](#error-handling-with-boxerror)
    * [从标准输入读取](#reading-from-stdin)
    * [用自定义类型处理错误](#error-handling-with-a-custom-type)
    * [增加功能](#adding-functionality)
* [小说版](#the-short-story)

## <a name="the-basics"></a>基础

你可以认为错误处理是用事例分析（case analysis）来决定一个计算成功与否。如你所见，工程性的错误处理就是要减少程序猿显式的事例分析的同时保持代码的可组合性。

保持代码的可组合性是很重要的，因为没有这个要求，我们可能在遇到没想到的情况时[panic](https://github.com/rust-lang/rust/blob/master/src/doc/std/macro.panic!.html)。（`panic`导致当前线程结束，而在大多数情况，导致整个程序结束。）这是一个例子：

```rust
// Guess a number between 1 and 10.
// If it matches the number we had in mind, return true. Else, return false.
fn guess(n: i32) -> bool {
    if n < 1 || n > 10 {
        panic!("Invalid number: {}", n);
    }
    n == 5
}

fn main() {
    guess(11);
}
```

如果你运行这段代码，程序会崩溃并输出类似如下信息：

```text
thread '<main>' panicked at 'Invalid number: 11', src/bin/panic-simple.rs:5
```
