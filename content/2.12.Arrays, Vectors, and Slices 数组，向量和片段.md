# 数组，向量和片段
像很多编程语言一样，Rust有用来表示数据序列的列表类型。最基本的是*数组*，一个定长相同类型的元素列表。数组默认是不可变的。

```rust
let a = [1, 2, 3]; // a: [i32; 3]
let mut m = [1, 2, 3]; // mut m: [i32; 3]
```

这里有一个可以将数组中每一个元素初始化为相同值的简写。在这个例子中，`a`的每个元素都被初始化为`0`：

```rust
let a = [0; 20]; // a: [i32; 20]
```

数组的类型是`[T; N]`。我们会在讲解泛型的时候讨论这个`T`标记。

你可以用`a.len()`来获取`a`中元素的数量，用`a.iter()`在循环中迭代所有元素。下面的代码会按顺序打印每一个元素：

```rust
let a = [1, 2, 3];

println!("a has {} elements", a.len());
for e in a.iter() {
    println!("{}", e);
}
```

你可以用*下标*（*subscript notation*）来访问特定的元素：

```rust
let names = ["Graydon", "Brian", "Niko"]; // names: [&str; 3]

println!("The second name is: {}", names[1]);
```

就跟大部分编程语言一个样，下标从0开始，所以第一个元素是`names[0]`，第二个是`names[1]`。上面的例子会打印出`The second name is: Brian`。如果你尝试使用一个不在数组中的下标，你会得到一个错误：数组访问会在运行时进行边界检查。这种不适当的访问时其它系统编程语言中很多bug的根源。

*向量*是一个动态或“可增长”的数组，被实现为标准库类型[Vec<T>](http://doc.rust-lang.org/std/vec/)（我们会在后面讨论`<T>是什么意思`）。向量一般在堆上分配数据。向量与片段就像`String`与`&str`一样。你可以使用`vec!`宏来创建它：

```rust
let v = vec![1, 2, 3]; // v: Vec<i32>
```

（与我们之前使用`println!`宏时不一样，我们可以在`vec!`中使用中括号`[]`。为了方便，Rust允许你使用上述情况。）

你可以获取向量的长度，迭代和使用下标，就像数组一样。另外，（可变）的向量会自动增长：

```rust
let mut nums = vec![1, 2, 3]; // mut nums: Vec<i32>

nums.push(4);

println!("The length of nums is now {}", nums.len()); // Prints 4
```

向量有很多有用的方法。

一个*片段*（*slice*）是一个数组的引用（或者“视图”）。它有利于安全，有效的访问数组的一部分而不用进行拷贝。距离来说，你可能只想要引用读入到内存的文件中的一行。原理上，片段并不是直接创建的，而是引用一个已经存在的变量。片段有长度，可以是可变也可以是不可变的，并且表现起来像一个数组。

```rust
let a = [0, 1, 2, 3, 4];
let middle = &a[1..4]; // A slice of a: just the elements 1, 2, and 3

for e in middle.iter() {
    println!("{}", e); // Prints 1, 2, 3
}
```

你也可以取向量的片段，例如`String`或者`&str`，因为向量的底层使用了数组。片段的类型是`&[T]`，我们会在讲泛型时讨论它。

我们现在已经学会了大部分Rust的基础知识。我们已经准备好创建你个猜猜看的游戏了，我们还需要知道最后一个内容：如如何从键盘获取输入。你不能在你都不能猜的情况下实现一个猜猜看的游戏！
