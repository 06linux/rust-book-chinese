# 闭包
到目前为止，我们已经写了不少Rust函数了，不过它们都有名字。Rust也允许我们创建匿名函数。Rust的匿名函数叫做*闭包*（*closures*）。闭包自身并不很有意思，不过当它们与用闭包作为参数的函数结合时，就可能灰常强大了。

让我们写一个闭包：
```rust
let add_one = |x| { 1 + x };

println!("The sum of 5 plus 1 is {}.", add_one(5));
```
我们用`|...| { ... }`语法来创建一个闭包，然后我们创建一个绑定方便我们后面使用它。注意我们调用闭包时使用绑定的名字和括号，就像我么调用命名函数一样。

让我们比较一下语法。这两个非常相似：
```rust
let add_one = |x: i32| -> i32 { 1 + x };
fn  add_one   (x: i32) -> i32 { 1 + x }
```
你可能注意到了，闭包会推断它参数和返回值的类型，所以你不需要声明它们。这与命名函数有所不同，它们默认返回单元（`()`）。

闭包和命名函数有一个巨大的区别，就在于1它们的名字：闭包“闭合了它的环境”。这是什么意思呢？它意味着：
```rust
fn main() {
    let x: i32 = 5;

    let printer = || { println!("x is: {}", x); };

    printer(); // prints "x is: 5"
}
```
`||`语法代表这个匿名闭包不带参数。没有它，我们就一块`{}`中的代码了。

换句话说，闭包可以访问定义它的作用域内的变量。闭包借用任何它使用的变量，所以下面是错误的：
```rust
fn main() {
    let mut x: i32 = 5;

    let printer = || { println!("x is: {}", x); };

    x = 6; // error: cannot assign to `x` because it is borrowed
}
```

## 移动闭包（Moving closures）
Rust第二种类型的闭包，叫做*移动闭包*（*moving closure*），移动闭包用`move`关键字来标明。移动闭包与正常闭包的区别是移动闭包总是获取它使用变量的所有权。正常闭包，相反，只是在自己所在的栈上创建一个引用。移动闭包在Rust的并发功能中最有用，所以我们现在先不讲它。我们会在“线程”部分更详细的介绍它。

## 闭包作为参数
闭包作为另一个函数的参数时最有用。这是个例子：
```rust
fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {
    f(x) + f(x)
}

fn main() {
    let square = |x: i32| { x * x };

    twice(5, square); // evaluates to 50
}
```
让我们把例子分开来看，从`main`开始：
```rust
let square = |x: i32| { x * x };
```
我们之前见过这个。我们创建了一个闭包获取一个整形，然后返回它的平方。
```rust
twice(5, square); // evaluates to 50
```
这一行更有意思。这里，我们调用函数，`twice`，我们传递了两个参数：一个整形，`5`，然后是我们的闭包，`square`。这跟向函数传递两个变量绑定并无区别，不过如果你之前并未接触过闭包，这看起来可能有点复杂。只需要想“我们传递了两个参数：一个是`i32`，一个是函数”就行。

下面，让我们看看`twice`是如何定义的：
```rust
fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {
```
`twice`有两个参数，`x`和`f`。这是它为什么我们调用它时传递两个参数。`x`是一个`i32`，我们已经很熟悉了。`f`是一个函数，不过它需要一个`i32`并返回一个`i32`。这是`Fn(i32) -> i32`类型的`F`的需要。现在`F`代表任何需要一个`i32`和返回一个`i32`的函数。

这可以是我们见过最复杂的函数标识了！多看几次直到你知道怎么用它了为止。这需要一些小的实践，然后就简单了。好消息是这样传递闭包时是非常有效率的。
