# 不安全和底层代码
## 介绍
Rust计划在CPU和操作系统的底层细节之上提供安全的抽象，不过有时我们需要编写底层代码。本教程旨在提供一个Rust不安全子集力量与危险的概括。

Rust提供了一个`unsafe { ... }`块这种形式的安全出口，它允许程序猿绕开编译器检查并进行大范围的操作，例如：
* 解引用[裸指针](http://doc.rust-lang.org/book/unsafe.html#raw-pointers)
* 通过FFI调用函数（[由FFI教程介绍](http://doc.rust-lang.org/book/ffi.html)）
* 二进制的转换类型（`transmute`，也就是指“强制类型转换”）
* [内联汇编](http://doc.rust-lang.org/book/unsafe.html#inline-assembly)

注意在`unsafe`并没有放松对`&`声明周期的监管和对借用数据的锁定。

`unsafe`的使用代表着程序员“比编译器知道的更多”，并且因此，程序员必须非常确信他们确实比这段代码为何是有效的知道的更多。总体来说，他们应该在代码库中尽可能减少不安全代码的数量；倾向于使用最少的`unsafe`块来构建安全的接口。

> **注意**：Rust语言的底层细节仍在不断改变中，并且没有稳定性和后向兼容性的保证。特别的，可能会有不会造成编译错误，不过会导致语义改变（例如使用未定义的行为）的修改。因此，使用时需要格外小心。

## 指针
### 引用
Rust最大的功能之一是内存安全。这部分依赖于[所有权系统](http://doc.rust-lang.org/book/ownership.html)，它使得编译器可以确保每一个`&`引用总是有效的，并且，例如，从不指向被释放的内存。

对`&`的限制有巨大的优势。然而，这也限制了我们对它的使用。例如，`&`与C指针并不相同，因此并不能在外部语言接口（FFI）中作为指针使用。另外，不可变和可变引用有一些混淆和冻结的保证，作为内存安全的需要。

特别的，如果你有一个`&T`引用，那么`T`肯定不能通过这个引用或其它引用被修改。一些像`Cell`和`RefCell`的标准库类型类型，它们通过用运行时动态检查代替编译时保障来提供内部的可变性。

`&mut`有一个不同的约束：如果一个对象有一个`&mut T`指向它，那么这`&mut`引用必须是整个程序中唯一一个指向该对象的可用路径。也就是说，`&mut`不能是任何其它引用的别名。

使用`unsafe`代码来不正确的绕过和违反这些限制会导致没有定义的行为。例如，下面的包装箱创建了两个混淆的`&mut`指针，而这时无效的。
```rust
use std::mem;
let mut x: u8 = 1;

let ref_1: &mut u8 = &mut x;
let ref_2: &mut u8 = unsafe { mem::transmute(&mut *ref_1) };

// oops, ref_1 and ref_2 point to the same piece of data (x) and are
// both usable
*ref_1 = 10;
*ref_2 = 20;
```

## 裸指针
Rust提供另外两种指针类型（裸指针），写作`*const T`和`*mut T`。它们分别与C的`const T*`和`T*`类似；实际上，它们最常用的作用之一就是FFI，与外部C库交互。

与Rust语言和库提供的其它指针类型相比裸指针拥有更少的保障。例如，它
* 不能保证指向有效的内存，甚至不能保证是非空的（不像`Box`和`&`）；
* 没有任何自动清除，不像`Box`，所以需要手动管理资源；
* 是普通旧式类型，也就是说，它不移动所有权，这也不像`Box`，因此Rust编译器不能保证不出像释放后使用这种bug；
* 被认为是可发送的（如果它的内容是可发送的），因此编译器不能提供帮助确保它的使用是线程安全的；例如，你可以从两个线程中并发的访问`*mut i32`而不用同步。
* 缺少任何形式的生命周期，不像`&`，因此编译器不能判断出悬垂指针；
* 缺少关于别名的保障，除非使用`*const T`直接不允许改变，也缺少可变性的保障。

幸运的是，它有一个补偿功能：更弱的保障意味着更弱的限制。缺失的限制使得裸指针适合编写实现库中像智能指针和向量的构建模块。例如，`*`指针允许别名，使得他可以用来编写像引用计数和垃圾回收的指针这样的共享所有权类型，甚至是线程安全的共享内存类型（`Rc`和`Arc`类型都是完全用Rust实现的）。

关于裸指针有两点你需要注意（也就是说需要`unsafe { ... }`块）：
* 解引用：它可以拥有任何值：所以可能的结果包括崩溃，读取未初始化内存，释放后使用，或者正常的数据读取。
* 通过`offset`[Intrinsics](http://doc.rust-lang.org/book/unsafe.html#intrinsics)（或者`.offset`方法）的指针算术：
