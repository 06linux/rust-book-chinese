# 不安全和底层代码
## 介绍
Rust计划在CPU和操作系统的底层细节之上提供安全的抽象，不过有时我们需要编写底层代码。本教程旨在提供一个Rust不安全子集力量与危险的概括。

Rust提供了一个`unsafe { ... }`块这种形式的安全出口，它允许程序猿绕开编译器检查并进行大范围的操作，例如：
* 解引用[裸指针](http://doc.rust-lang.org/book/unsafe.html#raw-pointers)
* 通过FFI调用函数（[由FFI教程介绍](http://doc.rust-lang.org/book/ffi.html)）
* 二进制的转换类型（`transmute`，也就是指“强制类型转换”）
* [内联汇编](http://doc.rust-lang.org/book/unsafe.html#inline-assembly)

注意在`unsafe`并没有放松对`&`声明周期的监管和对借用数据的锁定。

`unsafe`的使用代表着程序员“比编译器知道的更多”，并且因此，程序员必须非常确信他们确实比这段代码为何是有效的知道的更多。总体来说，他们应该在代码库中尽可能减少不安全代码的数量；倾向于使用最少的`unsafe`块来构建安全的接口。

> **注意**：Rust语言的底层细节仍在不断改变中，并且没有稳定性和后向兼容性的保证。特别的，可能会有不会造成编译错误，不过会导致语义改变（例如使用未定义的行为）的修改。因此，使用时需要格外小心。

## 指针
### 引用
Rust最大的功能之一是内存安全。这部分依赖于[所有权系统](http://doc.rust-lang.org/book/ownership.html)，它使得编译器可以确保每一个`&`引用总是有效的，并且，例如，从不指向被释放的内存。

对`&`的限制有巨大的优势。然而，这也限制了我们对它的使用。例如，`&`与C指针并不相同，因此并不能在外部语言接口（FFI）中作为指针使用。另外，不可变和可变引用有一些混淆和冻结的保证，作为内存安全的需要。

特别的，如果你有一个`&T`引用，那么`T`肯定不能通过这个引用或其它引用被修改。一些像`Cell`和`RefCell`的标准库类型类型，它们通过用运行时动态检查代替编译时保障来提供内部的可变性。

`&mut`有一个不同的约束：如果一个对象有一个`&mut T`指向它，那么这`&mut`引用必须是整个程序中唯一一个指向该对象的可用路径。也就是说，`&mut`不能是任何其它引用的别名。

使用`unsafe`代码来不正确的绕过和违反这些限制会导致没有定义的行为。例如，下面的包装箱创建了两个混淆的`&mut`指针，而这时无效的。
```rust
use std::mem;
let mut x: u8 = 1;

let ref_1: &mut u8 = &mut x;
let ref_2: &mut u8 = unsafe { mem::transmute(&mut *ref_1) };

// oops, ref_1 and ref_2 point to the same piece of data (x) and are
// both usable
*ref_1 = 10;
*ref_2 = 20;
```

## 裸指针
Rust提供另外两种指针类型（裸指针），写作`*const T`和`*mut T`。它们分别与C的`const T*`和`T*`类似；实际上，它们最常用的作用之一就是FFI，与外部C库交互。

与Rust语言和库提供的其它指针类型相比裸指针拥有更少的保障。例如，它
* 不能保证指向有效的内存，甚至不能保证是非空的（不像`Box`和`&`）；
* 没有任何自动清除，不像`Box`，所以需要手动管理资源；
* 是普通旧式类型，也就是说，它不移动所有权，这也不像`Box`，因此Rust编译器不能保证不出像释放后使用这种bug；
* 被认为是可发送的（如果它的内容是可发送的），因此编译器不能提供帮助确保它的使用是线程安全的；例如，你可以从两个线程中并发的访问`*mut i32`而不用同步。
* 缺少任何形式的生命周期，不像`&`，因此编译器不能判断出悬垂指针；
* 缺少关于别名的保障，除非使用`*const T`直接不允许改变，也缺少可变性的保障。

幸运的是，它有一个补偿功能：更弱的保障意味着更弱的限制。缺失的限制使得裸指针适合编写实现库中像智能指针和向量的构建模块。例如，`*`指针允许别名，使得他可以用来编写像引用计数和垃圾回收的指针这样的共享所有权类型，甚至是线程安全的共享内存类型（`Rc`和`Arc`类型都是完全用Rust实现的）。

关于裸指针有两点你需要注意（也就是说需要`unsafe { ... }`块）：
* 解引用：它可以拥有任何值：所以可能的结果包括崩溃，读取未初始化内存，释放后使用，或者正常的数据读取。
* 通过`offset`[Intrinsics](http://doc.rust-lang.org/book/unsafe.html#intrinsics)（或者`.offset`方法）的指针算术：这个intrinsic使用所谓的“界内”算术，这就是说，如果结果是在原始指针指向的对象之内（或者是结尾之后的一个字节）的这是唯一定义了的行为。

后一个假设使得编译器可以更有效的优化。就像你看到的，实际“创建”一个裸指针是不安全的，即便是把它转换为整形。

### 引用和裸指针
在运行时，指向同样一片数据的裸指针和引用有相同的表现。事实上，在安全代码中`&T`引用会隐式转换为一个`*const T`裸指针而`mut`变体也有相似的情况（这两个转换都可以显式进行，分别生成`value as *const T`和`value as *mut T`）。

反过来，把`*const`转换为`&`是不安全的。`&T`总是有效的，因此，最少裸指针`*const T`必须得指向一个有效的`T`的实例。此外，得到的指针必须满足引用的别名和可变性规则。编译器假设这些属性使用与任何引用，不过它是如何创建的，所以任何裸指针的转换都断言它们满足这些条件，程序猿*必须*保证这些。

推荐的转换方法是：
```rust
let i: u32 = 1;
// explicit cast
let p_imm: *const u32 = &i as *const u32;
let mut m: u32 = 2;
// implicit coercion
let p_mut: *mut u32 = &mut m;

unsafe {
    let ref_imm: &u32 = &*p_imm;
    let ref_mut: &mut u32 = &mut *p_mut;
}
```
`&*x`解引用风格倾向于使用`transmute`。后一种方法远比需要的强力，并且限制更严格的操作更难出错；例如，它要求`x`是一个指针（不像`transmute`）

## 使不安全变（更）安全
这里有多种方法在有不安全代码时导出安全的接口：
* 私有的保存指针（也就是说，不在公有结构体的公有字段中），这样你可以在一个地方看见和控制对指针的所有读写。
* 多使用`assert!()`：因为你不能依靠编译器或类型系统保证你的`unsafe`代码在编译时是正确的，使用`assert!()`来验证它们会在运行时正常工作。
* 为资源实现`Drop`以便通过析构函数清理，并遵循RAII（资源获取就是初始化）原则。这减少了任何手动内存管理的需要，并且确保清理总会自动运行，即便是线程恐慌的情况下。
* 确保任何储存在一个裸指针中的数据都在合适的时间被销毁。

作为一个例子，我们通过封装`malloc`和`free`来重新实现一个我们自己的装箱。Rust的移动语义和生命周期意味着这个重新实现与`Box`一样安全。
```rust
#![feature(unsafe_destructor)]

extern crate libc;
use libc::{c_void, size_t, malloc, free};
use std::mem;
use std::ptr;

// Define a wrapper around the handle returned by the foreign code.
// Unique<T> has the same semantics as Box<T>
pub struct Unique<T> {
    // It contains a single raw, mutable pointer to the object in question.
    ptr: *mut T
}

// Implement methods for creating and using the values in the box.

// NB: For simplicity and correctness, we require that T has kind Send
// (owned boxes relax this restriction).
impl<T: Send> Unique<T> {
    pub fn new(value: T) -> Unique<T> {
        unsafe {
            let ptr = malloc(mem::size_of::<T>() as size_t) as *mut T;
            // we *need* valid pointer.
            assert!(!ptr.is_null());
            // `*ptr` is uninitialized, and `*ptr = value` would
            // attempt to destroy it `overwrite` moves a value into
            // this memory without attempting to drop the original
            // value.
            ptr::write(&mut *ptr, value);
            Unique{ptr: ptr}
        }
    }

    // the 'r lifetime results in the same semantics as `&*x` with
    // Box<T>
    pub fn borrow<'r>(&'r self) -> &'r T {
        // By construction, self.ptr is valid
        unsafe { &*self.ptr }
    }

    // the 'r lifetime results in the same semantics as `&mut *x` with
    // Box<T>
    pub fn borrow_mut<'r>(&'r mut self) -> &'r mut T {
        unsafe { &mut *self.ptr }
    }
}

// A key ingredient for safety, we associate a destructor with
// Unique<T>, making the struct manage the raw pointer: when the
// struct goes out of scope, it will automatically free the raw pointer.
//
// NB: This is an unsafe destructor, because rustc will not normally
// allow destructors to be associated with parameterized types, due to
// bad interaction with managed boxes. (With the Send restriction,
// we don't have this problem.) Note that the `#[unsafe_destructor]`
// feature gate is required to use unsafe destructors.
#[unsafe_destructor]
impl<T: Send> Drop for Unique<T> {
    fn drop(&mut self) {
        unsafe {
            // Copy the object out from the pointer onto the stack,
            // where it is covered by normal Rust destructor semantics
            // and cleans itself up, if necessary
            ptr::read(self.ptr);

            // clean-up our allocation
            free(self.ptr as *mut c_void)
        }
    }
}

// A comparison between the built-in `Box` and this reimplementation
fn main() {
    {
        let mut x = Box::new(5);
        *x = 10;
    } // `x` is freed here

    {
        let mut y = Unique::new(5);
        *y.borrow_mut() = 10;
    } // `y` is freed here
}
```
需要注意的是，唯一可以创建`Unique`的方法是通过`new`函数，并且这个函数确保了它内部的指针式有效且隐藏在私有字段中。那二个`borrow`方法是安全的因为编译器静态的保证了对象绝不会在创建之前或销毁之后被使用（除非你在`unsafe`代码中用它们...）。

## 内联汇编
为了极端底层操作和性能要求，你可能希望直接控制CPU。Rust通过`asm!`宏来支持使用内联汇编。语法大体上与GCC和Clang相似：
```rust
asm!(assembly template
   : output operands
   : input operands
   : clobbers
   : options
   );
```
任何`asm`的使用需要功能通道（需要在包装箱上加上`#![feature(asm)]`来允许使用）并且当然也需要写在`unsafe`块中

> **注意**：这里的例子使用了x86/x86-64汇编，不过所有平台都受支持。

### 汇编模板
`assembly template`是唯一需要的参数并且必须是原始字符串（就是`""`）
```rust
#![feature(asm)]

#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
fn foo() {
    unsafe {
        asm!("NOP");
    }
}

// other platforms
#[cfg(not(any(target_arch = "x86", target_arch = "x86_64")))]
fn foo() { /* ... */ }

fn main() {
    // ...
    foo();
    // ...
}
```
（`feature(asm)`和`#[cfg]`从现在开始将被忽略。）

输出操作数，输入操作数，覆盖和选项都是可选的不过你必选加上正确数量的`:`如果你要省略它们的话：
```rust
asm!("xor %eax, %eax"
    :
    :
    : "eax"
   );
```
空格是无所谓的：
```rust
asm!("xor %eax, %eax" ::: "eax");
```

### 操作数
输入和输出操作数都有相同的格式：`: "constraints1"(expr1), "constraints2"(expr2), ..."`。输出操作数表达式必须是可变的左值：
```rust
fn add(a: i32, b: i32) -> i32 {
    let mut c = 0;
    unsafe {
        asm!("add $2, $0"
             : "=r"(c)
             : "0"(a), "r"(b)
             );
    }
    c
}

fn main() {
    assert_eq!(add(3, 14159), 14162)
}
```

### 覆盖
一些指令修改可能保存有不同值寄存器所以我们使用覆盖列表来告诉编译器不要假设任何装载在这些寄存器的值是有效的。
```rust
// Put the value 0x200 in eax
asm!("mov $$0x200, %eax" : /* no outputs */ : /* no inputs */ : "eax");
```
输入和输出寄存器并不需要列出因为这些信息已经通过给出的限制沟通过了。因此，任何其它的被使用的寄存器应该隐式或显式的被列出。

如果汇编修改了代码状态寄存器`cc`则需要在覆盖中被列出，如果汇编修改了内存，`memory`也应被指定。

### 选项
最后一部分，`options`是Rust特有的。格式是逗号分隔的基本字符串（也就是说，`:"foo", "bar", "baz"`）。它被用来指定关于内联汇编的额外信息：

目前有效的选项有：

1. *volatile* - 相当于gcc/clang中的`__asm__ __volatile__ (...)`
2. *alignstack* - 特定的指令需要栈按特定方式对齐（比如，SSE）并且指定这个告诉编译器插入通常的栈对齐代码
3. *intel* - 使用intel语法而不是默认的AT&T语法

## 避免使用标准库
`std`默认被链接到每个Rust包装箱中。在一些情况下，这是不合适的，并且可以通过在包装箱上加入`#![no_std]`属性来避免这一点。
```rust
// a minimal library
#![crate_type="lib"]
#![feature(no_std)]
#![no_std]
```
很明显不光库可以使用这一点：你可以在可执行文件上使用`#[no_std]`，控制程序入口点有两种可能的方式：`#[start]`属性，或者用你自己的去替换C语言默认的`main`函数。

被标记为`#[start]`的函数传递的参数格式与C一致：
```rust
#![feature(lang_items, start, no_std)]
#![no_std]

// Pull in the system libc library for what crt0.o likely requires
extern crate libc;

// Entry point for this program
#[start]
fn start(_argc: isize, _argv: *const *const u8) -> isize {
    0
}

// These functions and traits are used by the compiler, but not
// for a bare-bones hello world. These are normally
// provided by libstd.
#[lang = "stack_exhausted"] extern fn stack_exhausted() {}
#[lang = "eh_personality"] extern fn eh_personality() {}
#[lang = "panic_fmt"] fn panic_fmt() -> ! { loop {} }
```

要覆盖编译器插入的`main`函数，你必须使用`#![no_main]`并通过正确的ABI和正确的名字来创建合适的函数，这也需要需要覆盖编译器的命名改编：
```rust
#![feature(no_std)]
#![no_std]
#![no_main]
#![feature(lang_items, start)]

extern crate libc;

#[no_mangle] // ensure that this symbol is called `main` in the output
pub extern fn main(argc: i32, argv: *const *const u8) -> i32 {
    0
}

#[lang = "stack_exhausted"] extern fn stack_exhausted() {}
#[lang = "eh_personality"] extern fn eh_personality() {}
#[lang = "panic_fmt"] fn panic_fmt() -> ! { loop {} }
```
目前编译器对能够被可执行文件调用的符号做了一些假设。正常情况下，这些函数是由标准库提供的，不过没有它你就必须定义你自己的了。

这三个函数中的第一个`stack_exhausted`，当检测到栈溢出时被调用。这个函数对于如何被调用和应该干什么有一些限制，不顾如果栈限制寄存器没有被维护则一个线程可以有”无限的栈“，这种情况下这个函数不应该被触发。

第二个函数，`eh_personality`，被编译器的错误机制使用。它通常映射到GCC的特性函数上（查看[libstd实现](http://doc.rust-lang.org/std/rt/unwind/)来获取更多信息），不过对于不会触发恐慌的包装箱可以确定这个函数不会被调用。最后一个函数，`panic_fmt`，也被编译器的错误机制使用。

### 使用libcore
> **注意**：核心库的结构是不稳定的，建议在任何可能的情况下使用标准库。

