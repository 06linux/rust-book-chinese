# 选择你的保证

作为语言Rust的一个重要特性是允许我们控制一个程序的开销和（安全）保证。

Rust标准库中有多种“包装类型”的抽象，他们代表了大量在开销，工程学和安全保证之间的权衡。很多让你在运行时和编译时增强之间选择。这一部分将会详细解释一些特定的抽象。

在开始之前，强烈建议你阅读Rust的[所有权](https://doc.rust-lang.org/stable/book/ownership.html)和[借用](https://doc.rust-lang.org/stable/book/references-and-borrowing.html)。

## 基础指针类型

### `Box<T>`

[Box<T>](https://doc.rust-lang.org/stable/std/boxed/struct.Box.html)是一个“自我拥有的”，或者“装箱”的指针。因为它可以维持引用和包含的数据，它是数据的唯一的拥有者。特别的，当执行类似如下代码时：

```rust
let x = Box::new(1);
let y = x;
// x no longer accessible here
```

这里，装箱被*移动*进了`y`。因为`x`不再拥有它，此后编译器不再允许程序猿使用`x`。相似的一个函数可以通过返回装箱来*移出*函数。

当一个装箱（还没有被移动的）离开了作用域，析构函数将会运行。这个析构函数负责释放内部的数据。

这是一个动态分配的零开销抽象。如果你想要在堆上分配一些内存并安全的传递这些内存的指针，这是理想的情况。注意你将只能通过正常的借用规则来共享引用，这些在编译时被检查。

### `&T`和`&mut T`

这分别是不可变和可变引用。他们遵循“读写锁”的模式，也就是你只可能拥有一个数据的可变引用，或者任意数量的不可变医用，但不是两者都有。这个保证在编译时执行，并且没有明显的运行时开销。在大部分情况这两个指针类型有能力在代码块之间廉价的共享引用。

这些指针不能在超出他们的生命周期的情况下被拷贝。

### `*const T`和`*mut T`

这些是C风格的指针，并没附加生命周期或所有权。他们只是指向一些内存位置，没有其他的限制。他们能提供的唯一的保证是除非在标记为`unsafe`的代码中他们不会被解引用。

他们在构建像`Vec<T>`这样的安全，低开销抽象时是有用的，不过应该避免在安全代码中使用。

### `Rc<T>`
这是第一个我们将会介绍到的有运行时开销的包装类型。

[Rc<T>](https://doc.rust-lang.org/stable/std/rc/struct.Rc.html)是一个引用计数指针。换句话说，这让我们拥有相同数据的多个“有所有权”的指针，并且数据在所有指针离开作用域后将被释放（析构函数将会执行）。

在内部，它包含一个共享的“引用计数”（也叫做“refcount”），每次`Rc`被拷贝时递增，而每次`Rc`离开作用域时递减。`Rc<T>`的主要职责是确保共享的数据的析构函数被调用。

这里内部的数据是不可变的，并且如果创建了一个循环引用，数据将会泄露。如果我们想要数据在存在循环引用时不被泄漏，我们需要一个垃圾回收器。

### 保证

这些（基础指针）类型提供的主要保证是当所有引用离开作用域之前，相关数据将不会被销毁。

这些类型将被用在当你想要动态分配并在程序中的多个位置共享一些数据，同时并不确定哪一部分程序将会最后使用这些指针的情况。
