# 选择你的保证

作为语言Rust的一个重要特性是允许我们控制一个程序的开销和（安全）保证。

Rust标准库中有多种“包装类型”的抽象，他们代表了大量在开销，工程学和安全保证之间的权衡。很多让你在运行时和编译时增强之间选择。这一部分将会详细解释一些特定的抽象。

在开始之前，强烈建议你阅读Rust的[所有权](https://doc.rust-lang.org/stable/book/ownership.html)和[借用](https://doc.rust-lang.org/stable/book/references-and-borrowing.html)。

## 基础指针类型

### `Box<T>`

[Box<T>](https://doc.rust-lang.org/stable/std/boxed/struct.Box.html)是一个“自我拥有的”，或者“装箱”的指针。因为它可以维持引用和包含的数据，它是数据的唯一的拥有者。特别的，当执行类似如下代码时：

```rust
let x = Box::new(1);
let y = x;
// x no longer accessible here
```

这里，装箱被*移动*进了`y`。因为`x`不再拥有它，此后编译器不再允许程序猿使用`x`。相似的一个函数可以通过返回装箱来*移出*函数。

当一个装箱（还没有被移动的）离开了作用域，析构函数将会运行。这个析构函数负责释放内部的数据。

这是一个动态分配的零开销抽象。如果你想要在堆上分配一些内存并安全的传递这些内存的指针，这是理想的情况。注意你将只能通过正常的借用规则来共享引用，这些在编译时被检查。

### `&T`和`&mut T`

这分别是不可变和可变引用。他们遵循“读写锁”的模式，也就是你只可能拥有一个数据的可变引用，或者任意数量的不可变医用，但不是两者都有。这个保证在编译时执行，并且没有明显的运行时开销。在大部分情况这两个指针类型有能力在代码块之间廉价的共享引用。

这些指针不能在超出他们的生命周期的情况下被拷贝。

### `*const T`和`*mut T`

这些是C风格的指针，并没附加生命周期或所有权。他们只是
