# 选择你的保证

作为语言Rust的一个重要特性是允许我们控制一个程序的开销和（安全）保证。

Rust标准库中有多种“包装类型”的抽象，他们代表了大量在开销，工程学和安全保证之间的权衡。很多让你在运行时和编译时增强之间选择。这一部分将会详细解释一些特定的抽象。

在开始之前，强烈建议你阅读Rust的[所有权](https://doc.rust-lang.org/stable/book/ownership.html)和[借用](https://doc.rust-lang.org/stable/book/references-and-borrowing.html)。

## 基础指针类型

### `Box<T>`

[Box<T>](https://doc.rust-lang.org/stable/std/boxed/struct.Box.html)是一个“自我拥有的”，或者“装箱”的指针。因为它可以维持引用和包含的数据，它是数据的唯一的拥有者。特别的，当执行类似如下代码时：

```rust
let x = Box::new(1);
let y = x;
// x no longer accessible here
```

这里，装箱被*移动*进了`y`。因为`x`不再拥有它，此后编译器不再允许程序猿使用`x`。相似的一个函数可以通过返回装箱来*移出*函数。

当一个装箱（还没有被移动的）离开了作用域，析构函数将会运行。这个析构函数负责释放内部的数据。

这是一个动态分配的零开销抽象。如果你想要在堆上分配一些内存并安全的传递这些内存的指针，这是理想的情况。注意你将只能通过正常的借用规则来共享引用，这些在编译时被检查。

### `&T`和`&mut T`

这分别是不可变和可变引用。他们遵循“读写锁”的模式，也就是你只可能拥有一个数据的可变引用，或者任意数量的不可变医用，但不是两者都有。这个保证在编译时执行，并且没有明显的运行时开销。在大部分情况这两个指针类型有能力在代码块之间廉价的共享引用。

这些指针不能在超出他们的生命周期的情况下被拷贝。

### `*const T`和`*mut T`

这些是C风格的指针，并没附加生命周期或所有权。他们只是指向一些内存位置，没有其他的限制。他们能提供的唯一的保证是除非在标记为`unsafe`的代码中他们不会被解引用。

他们在构建像`Vec<T>`这样的安全，低开销抽象时是有用的，不过应该避免在安全代码中使用。

### `Rc<T>`
这是第一个我们将会介绍到的有运行时开销的包装类型。

[Rc<T>](https://doc.rust-lang.org/stable/std/rc/struct.Rc.html)是一个引用计数指针。换句话说，这让我们拥有相同数据的多个“有所有权”的指针，并且数据在所有指针离开作用域后将被释放（析构函数将会执行）。

在内部，它包含一个共享的“引用计数”（也叫做“refcount”），每次`Rc`被拷贝时递增，而每次`Rc`离开作用域时递减。`Rc<T>`的主要职责是确保共享的数据的析构函数被调用。

这里内部的数据是不可变的，并且如果创建了一个循环引用，数据将会泄露。如果我们想要数据在存在循环引用时不被泄漏，我们需要一个垃圾回收器。

#### 保证

这里（`Rc<T>`）提供的主要保证是当所有引用离开作用域之前，相关数据将不会被销毁。

这些类型将被用在当你想要动态分配并在程序中的多个位置共享一些数据，同时并不确定哪一部分程序将会最后使用这些指针的情况。它是一个`&T`的切实可行的替代，当`&T`既不可能静态的检查正确性，也不能写出非常高工程度的代码，这时程序猿并不希望产生开发花费。

这个指针并*不是*线程安全的，并且Rust也不会允许它被传递或共享给别的线程。这允许你在不必要的情况下的原子性开销。

这里有一个更智能的姐妹指针类型，`Weak<T>`。它是一个既没有所有权，也不能被借用，的智能指针。它也比较像`&T`，但并没有生命周期的限制--一个`Weak<T>`可以一直存活。然而，尝试对其内部数据进行访问可能失败并返回`None`，因为它可以比有所有权的`Rc`存活更久。这对循环数据结构和一些其他类型是有用的。

#### 开销

随着内存使用增加，`Rc<T>`是一次性的分配，虽然相比一个常规`Box<T>`它会多分配额外两个字（也就是说，两个`usize`值）。（“强”引用计数相比“弱”引用计数）。

`Rc<T>`分别在拷贝和离开作用域时会产生递增/递减引用计数的计算型开销。注意拷贝将不会进行一次深度复制，相反它会简单的递增内部引用计数并返回一个`Rc<T>`的拷贝。

## Cell类型

`Cell`提供内部可变性。换句话说，他们包含的数据可以被修改，即便是这个类型并不能以可变形式获取（例如，当他们位于一个`&`指针或`Rc<T>`之后时）。

[对此`cell`模块的文档有一个非常好的解释](https://doc.rust-lang.org/stable/std/cell/)。

这些类型*经常*在结构体字段中出现，不过他们也可能在其他一些地方找到。

### `Cell<T>`

[Cell<T>](https://doc.rust-lang.org/stable/std/cell/struct.Cell.html)是一个提供了零开销内部可变性的类型，不过只用于`Copy`类型。因为编译器知道它包含的值对应的所有数据都位于栈上，所以并没有通过简单的替换数据而导致任何位于引用之后的数据泄露（或者更糟！）的担心。

然而使用这个封装仍有可能违反你自己的不可变性，所以谨慎的使用它。它是一个很好的标识，表明一些数据块是可变的并且可能在你第一次读取它和当你想要使用它时的值并不一样。

```rust
use std::cell::Cell;

let x = Cell::new(1);
let y = &x;
let z = &x;
x.set(2);
y.set(3);
z.set(4);
println!("{}", x.get());
```

注意这里我们可以通过多个不可变的引用改变相同的值。

这与如下代码有相同的运行时开销：

```rust
let mut x = 1;
let y = &mut x;
let z = &mut x;
x = 2;
*y = 3;
*z = 4;
println!("{}", x);
```

不过它有额外的优势，它确实能够编译成功。（高级黑？）

#### 保证

这个类型放宽了当没有必要时“没有因可变性导致的混淆”的限制。然而，这也放宽了这个限制提供的保证；所以当你的不可变量依赖存储在`Cell`中的数据，你应该多加小心。

这对改变基本类型和其他`Copy`类型非常有用，当通过`&`和`&mut`的静态规则并没有其他简单合适的方法改变他们的值时。

#### 开销

使用`Cell<T>`并没有运行时开销，不过你使用它来封装一个很大的（`Copy`）结构体，可能更适合封装单独的字段为`Cell<T>`因为每次写入都会是一个结构体的完整拷贝。

### `RefCell<T>`

[RefCell<T>](https://doc.rust-lang.org/stable/std/cell/struct.RefCell.html)也提供了内部可变性，不过并不限制为`Copy`类型。

相对的，它有运行时开销。`RefCell<T>`在运行时使用了读写锁模式，不像`&T`/`&mut T`那样在编译时执行。这通过`borrow()`和`borrow_mut()`函数来实现，它修改一个内部引用计数并分别返回可以不可变的和可变的解引用的智能指针。当智能指针离开作用域引用计数将被恢复。通过这个系统，我们可以动态的确保当有一个有效的可变借用时绝不会有任何其他有效的借用。如果程序猿尝试创建一个这样的借用，线程将会恐慌。

```rust
use std::cell::RefCell;

let x = RefCell::new(vec![1,2,3,4]);
{
    println!("{:?}", *x.borrow())
}

{
    let mut my_ref = x.borrow_mut();
    my_ref.push(1);
}
```

与`Cell`相似，它主要用于难以或不可能满足借用检查的情况。大体上我们知道这样的改变不会发生在一个嵌套的形式中，不过检查一下是有好处的。

对于大型的，复杂的程序，把一些东西放入`RefCell`来将事情变简单是有用的。例如，Rust编译器内部的[`ctxt`结构体](https://doc.rust-lang.org/stable/rustc/middle/ty/struct.ctxt.html)中的很多map都在这个封装中。他们只会被修改一次（在创建时，但并不在初始化之后立即执行）或者位于明显分开的地方的多次。然而，因为这个结构体被广泛的用于各个地方，有效的组织可变和不可变的指针将会是困难的（也许是不可能的），并且可能产生大量的难以扩展的`&`指针。换句话说，`RefCell`提供了一个廉价（并不是零开销）的方式来访问它。之后，如果有人增加一些代码来尝试修改一个已经被借用的cell时，这将会产生（通常是决定性的）一个恐慌，并会被追溯到那个可恶的借用上。

相似的，在Servo的DOM中有很多可变量，大部分对于一个DOM类型都是本地的，不过有一些交错在DOM中并修改了很多内容。
