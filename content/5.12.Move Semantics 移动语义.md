# 移动语义
[所有权](http://doc.rust-lang.org/nightly/book/ownership.html)的一个重要的方面是“移动语义”。移动语义控制所有权如何和何时在绑定中传递。

例如，考虑一个像`Vec<T>`的类型，它拥有它的内容：

```rust
let v = vec![1, 2, 3];
```

我可以把这个向量赋值给另一个绑定：

```rust
let v = vec![1, 2, 3];

let v2 = v;
```

不过，如果我们在之后尝试使用`v`，我们得到一个错误：

```rust
let v = vec![1, 2, 3];

let v2 = v;

println!("v[0] is: {}", v[0]);
```

它看起来像这样：

```rust
error: use of moved value: `v`
println!("v[0] is: {}", v[0]);
                        ^
```

如果我们定义了一个会取得所有权的函数，并且在之后尝试使用我们作为参数传递的变量会发生相似的事情：

```rust
fn take(v: Vec<i32>) {
    // what happens here isn’t important.
}

let v = vec![1, 2, 3];

take(v);

println!("v[0] is: {}", v[0]);
```

同样的错误：“使用了移动的值。”当我们把所有权传递给别的变量，我们说我们“移动”了我们引用的东西。在这里你不需要一些特殊的注解，这是Rust的默认行为。

## 细节
我们不能在移动后使用一个绑定的原因是很微妙的，不过很重要。当我们像这样写代码：

```rust
let v = vec![1, 2, 3];

let v2 = v;
```

第一行为向量在栈上创建了一些数据，`v`。向量的数据，然而，存储在堆上，并且因此它包含一个指向数据的指针。当我们从`v`移动到`v2`，它创建了一个那些数据的拷贝（注：非堆上的数据，应该是栈上的数据），为了`v2`。它意味着两个指向堆上向量内容的指针。这会有一个问题：它会因引入了数据竞争而违反Rust的安全保障。因此，Rust禁止在我们移动后使用`v`。

认识到根据特定情况优化可能会移除这些字节的拷贝也是很重要的。所以它可能不像它开始感觉的那么没效率。

## `Copy`类型
我们建立了当所有权传递到另一个绑定时，你不能使用原始绑定的观念。然而，这里有一个[特性](http://doc.rust-lang.org/nightly/book/traits.html)可以改变这个行为，而它叫`Copy`。我们还未谈到特性，不过目前为止，你可以理解为它们是一个为特定类型增加额外行为的注解。例如：

```rust
let v = 1;

let v2 = v;

println!("v is: {}", v);
```

在这个情况，`v`是一个`i32`，它实现了`Copy`特性。这意味着，就像一个移动，当我们把`v`赋值给`v2`,产生了一个数据的拷贝。不过，不像一个移动，我们仍可以在之后使用`v`。这是因为`i32`并没有指向其它数据的指针，对它的拷贝是一个完整的拷贝。

我们会在[特性](http://doc.rust-lang.org/nightly/book/traits.html)部分讨论如何编写你自己类型的`Copy`。
