# 所有权
本教程展示Rust的所有权系统。这也是Rust最独特最引人入胜的特性之一，也是作为Rust开发者应该知晓的。所有权是Rust取得其最大的目标内存安全的关键。所有权系统有一些不同的主题：所有权，借用和生命周期。让我们来依此讨论它们。

## 原则（Meta）
在我们开始详细讲解之前，这有两点关于所有权系统重要的注意事项。

Rust注重安全和速度。它通过很多*零开销抽象*（*zero-cost abstractions*）来实现这些目标，也就是说在Rust中，实现抽象的开销尽可能的小。所有权系统是一个主要的零开销抽象的例子。本文提到所有的分析都是*在编译时完成的*。你不需要在运行时为这些功能付出任何开销。

然而，这个系统确实有一个开销：学习曲线。很多Rust初学者会经历我们所谓的“与借用检查器作斗争”的过程，也就是指Rust编译器拒绝编译一个作者认为合理的程序。这经常发生因为程序猿关于所有权系统如何工作的心智模型与Rust实现的现实规则不匹配。你最开始可能会有相似的经历。然而这是一个好消息：更有经验的Rust开发者反应一旦他们适应所有权系统一段时间之后，与借用检查器的冲突会越来越少。

记住这些之后，让我们学习所有权。

## 所有权（Ownership）
作为它的核心，所有权是关于*资源*（*resources*）的。作为本文大部分内容的目的，我们讨论一个特定的资源：内存。这个原则可以泛化到任何类型的资源，比如文件句柄，不过为了使它更加具体，我们将关注内存。

当你的程序分配了一些内存后。它需要一些释放它们的方法。想象一个函数`foo`分配4字节的内存，但之后从不释放内存。我们称之为内存*泄露*，因为我们每次调用`foo`，我们会分配另外4个字节。最终，调用足够多次`foo`后，我们会内存溢出。这是不好的。我们需要让`foo`释放那4个字节。另外，不要多次释放内存也很重要。在不涉及底层细节时，尝试释放同一内存多次可能导致问题。换句话说，每当一些内存被分配后，我们需要确保我们释放它一次且仅有一次。过度不好，不足也不行。数量必须正好。

关于分配内存还有一个重要的细节。每当我们获取一些内存的时候，我们会得到一个指向那片内存的句柄。这个句柄（通常叫做*指针*，当我们引用内存时）用来与被分配的内存交互。只要我们有这个句柄，我们就可以处理这篇内存。当我们不再保有句柄时，我们也就不再保有那片内存，因为没有句柄的话我们无法做任何事。

历史上，系统编程语言曾要求你自己关注分配，释放和句柄。例如，在像C这样的语言中如果你想要一些堆内存，我们这么做：
```c
    int *x = malloc(sizeof(int));

    // we can now do stuff with our handle x
    *x = 5;

    free(x);
}
```
`malloc`调用分配一些内存。`free`释放内存。它们也会记录分配内存的正确数量。
