# 指针
Rust的指针是它最独特最引人入胜的特性之一。指针也是对于Rust新人来说最令人迷惑的主题之一。对于来自像C++这样的支持指针的语言的同学来说它也会是令人迷惑的。这章教程会帮助你理解这个重要的主题。

对于非引用指针持怀疑态度：为了特定的目的使用它，而不是仅仅用它来调戏编译器。我们会解释每个指针类型何时适合使用它们。默认使用引用除非你处于任何一种特定的情况中。

你可能对这个[速查表](http://doc.rust-lang.org/book/pointers.html#cheat-sheet)有兴趣，它提供了一个关于不同指针类型，名称和使用目的的快速预览。

## 简介
如果你对指针的概念还不熟悉，这是一个简单的介绍。指针是系统编程语言中一个非常根本的概念，所以理解它们非常重要。

### 指针基础
当你创建一个新的变量绑定时，你给了一个储存在栈上特定位置的值一个名字（如果你对*堆和栈*（**heap vs. stack）的区别还不熟悉，请看看[这个Stack Overflow上的问题](http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap)，因为下面的介绍中假定你知道这些区别。）
例如：
```rust
let x = 5;
let y = 8;
```

| 地址 | 值 |
|------|----|
| 0xd3e030 | 5 |
| 0xd3e028 | 8 |
我们在这里补充了内存地址，它们都仅仅是虚构的值。不管如何，重点是`x`，我们给变量的名字。对应着内存地址`0xd3e030`，然后这个地址的值是`5`。当我们引用`x`时，我们获得对应的值。也就是说，`x`是`5`。

让我们来介绍指针。在一些语言中，这只有唯一一种类型的“指针”，不过在Rust中，我们有好几种指针。在这个例子中，我们用了一个`Rust`*引用*（*reference*），它是一种最简单的指针。
```rust
let x = 5;
let y = 8;
let z = &y;
```

| 地址 | 值 |
|------|----|
| 0xd3e030 | 5 |
| 0xd3e028 | 8 |
| 0xd3e020 | 0xd3e028 |
看出了区别了吗？并不是包含一个值，指针的值是内存中的地址。在我们的例子中，指的是`y`的地址。`x`和`y`是`i32`类型的，不过`z`是`&i32`类型的。我们可以用`{:p}`格式化字符串打印出这个地址：
```rust
let x = 5;
let y = 8;
let z = &y;

println!("{:p}", z);
```
这会打印出`0xd3e028`，那个我们虚构的内存地址。

因为`i32`和`&i32`是不同的类型。我们不能，比如，把它们相加：
```rust
let x = 5;
let y = 8;
let z = &y;

println!("{}", x + z);
```
这会给我们一个错误：
```bash
hello.rs:6:24: 6:25 error: mismatched types: expected `_`, found `&_` (expected integral variable, found &-ptr)
hello.rs:6     println!("{}", x + z);
                                  ^
```
我们可以用`*`运算符来*逆向引用*（*dereference*）指针。逆向引用是指访问储存在指针中地址的值。下面的代码可以工作：
```rust
let x = 5;
let y = 8;
let z = &y;

println!("{}", x + *z);
```
它会打印`13`。

好的！这就是指针的全部：它们指向一些内存地址。不是其它什么东西。现在我们讨论的*什么*是指针，让我们讨论一下*为什么*要用指针。

## 指针运用
Rust的指针非常有用，不过用起来跟其它系统语言有所不同。我们会在后面讲到Rust指针的最佳实践，不过在这里我们说说指针在其它语言中的用法：

在C语言中，字符串是一个`char`列表的指针，它以`null`字符结束。学会使用字符串的唯一方法唯有非常熟悉指针。

当需要指向不在栈上的内存地址时指针非常有用。举例来说，我们的例子用了两个栈变量，所以我们可以给它们命名。不过如果我们分配了一些堆内存，我们并没有可用的名字。在C语言中，`malloc`用来分配堆内存，并返回一个指针。

作为一个上面两点更宽泛的变体，任何时候如果你需要一个可变大小的结构，你就需要一个指针。你不能在编译时确定你需要分配多少内存，所以你需要一个指针指向将要分配内存的位置，然后在运行时处理它。

指针在值传递（pass-by-value）的语言中比在引用传递（pass-by-reference）的语言中有用。基本上，计算机语言可以做出两种选择（这是一个虚构的语法，不是Rust）：
```
func foo(x) {
    x = 5
}

func main() {
    i = 1
    foo(i)
    // what is the value of i here?
}
```
在一个值传递的语言中，`foo`是`i`的一个拷贝，然后原始的`f`并不会改变。此时，`i`仍是`1`。在一个引用传递的语言中，`foo`会是`i`的一个引用，并且因此，可以改变它的值。此时，`i`将是`5`。

那么指针用来干啥的呢？好吧，因为指针可以指向一个内存地址。。。
```
func foo(&i32 x) {
    *x = 5
}

func main() {
    i = 1
    foo(&i)
    // what is the value of i here?
}
```
即使在一个值传递的语言中，现在`i`也会是`5`。你可以看到，因为参数`x`是一个指针，我们确实传递了`foo`的拷贝，不过因为它指向一个内存地址，当我们后面赋值时，原始的值仍会被改变。这个模式叫做*通过值传递引用*（*pass-reference-by-value*）。非常微妙！

## 常见指针问题
我们现在讲述和赞颂了指针。那么缺点是什么？好吧，Rust尝试去减少这种问题，不过在其它语言中仍有这些问题：

未初始化的指针会造成麻烦。举例来说，下面的程序会怎么做？
```rust
&int x;
*x = 5; // whoops!
```
谁知道呢？
