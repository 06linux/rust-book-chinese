# 枚举
最后，Rust有一个”集合类型“，一个*枚举*。枚举是Rust一个极为有用的功能，他被用到了整个标准库中。枚举是一个类型，它把一系列互不相交的值绑到一起。举个例子来说，下面我们定义了一个`Character`，它的值只能是`Digit`或其它。你可以通过全名来使用它：`Character::Other`（下面介绍`::`）。

```rust
enum Character {
    Digit(i32),
    Other,
}
```

枚举的变量可以被定义为大部分正常类型。下面列出了一些可以在`enum`中使用的例子。

```rust
struct Empty;
struct Color(i32, i32, i32);
struct Length(i32);
struct Status { Health: i32, Mana: i32, Attack: i32, Defense: i32 }
struct HeightDatabase(Vec<i32>);
```

根据子数据类型的不同，就像结构体，`enum`变量，可以或可以不储存数据。就像在`Character`中，`Digit`绑定了一个`i32`，而`Other`只是一个名字。然而，它们两个的区别是非常有用的。

就像结构体一样，枚举默认不能使用像比较（`==`和`!=`），二进制操作（？`*`和`+`）和大小（`<`和`>=`）运算符。也就是说对于之前的`Character`类型，下面的代码是无效的：

```rust
// These assignments both succeed
let ten  = Character::Digit(10);
let four = Character::Digit(4);

// Error: `*` is not implemented for type `Character`
let forty = ten * four;

// Error: `<=` is not implemented for type `Character`
let four_is_smaller = four <= ten;

// Error: `==` is not implemented for type `Character`
let four_equals_ten = four == ten;
```

这看起来可能更像限制，不过这是一个我们可以克服的限制。我们有两种方法：实现一个我们自己的比较方法，或者使用[match](http://doc.rust-lang.org/book/match.html)关键字。我们还并不知道如何在Rust中实现比较方法，不过我们可以使用标准库中的`Ordering`枚举，它是：

```rust
enum Ordering {
    Less,
    Equal,
    Greater,
}
```

因为我们没有定义`Ordering`，我们必须使用`use`关键字（从标准库中）导入它。下面演示是如何使用`Ordering`的：

```rust
use std::cmp::Ordering;

fn cmp(a: i32, b: i32) -> Ordering {
    if a < b { Ordering::Less }
    else if a > b { Ordering::Greater }
    else { Ordering::Equal }
}

fn main() {
    let x = 5;
    let y = 10;

    let ordering = cmp(x, y); // ordering: Ordering

    if ordering == Ordering::Less {
        println!("less");
    } else if ordering == Ordering::Greater {
        println!("greater");
    } else if ordering == Ordering::Equal {
        println!("equal");
    }
}
```

`::`被用来表示命名空间。在这个李子中，`Ordering`存在于`std`模块的`cmp`子模块中。我们会在本书的后面讨论模块。现在，你只需知道你可以`use`标准库中你想要的东西。

好，让我们看看例子中实际的代码。`cmp`是一个函数，它比较两个数并返回一个`Ordering`。我们能够返回`Ordering::Less`，`Ordering::Greater`或者`Ordering::Equal`，根据这比较这两个值是小于，大于，或相等。注意`enum`的每一个变量都位于`enum`自己的命名空间中：是`Ordering::Greater`而不是`Greater`。

`ordering `变量是`Ordering`类型的，所以它是上面三个值中的一个。接着我们可以用一系列的`if/else`去检查每个值。

`Ordering::Greater`这个标记显得太长了。让我们用`use`导入`enum`的值。这样可以避免写完整的命名空间：

```rust
use std::cmp::Ordering::{self, Equal, Less, Greater};

fn cmp(a: i32, b: i32) -> Ordering {
    if a < b { Less }
    else if a > b { Greater }
    else { Equal }
}

fn main() {
    let x = 5;
    let y = 10;

    let ordering = cmp(x, y); // ordering: Ordering

    if ordering == Less { println!("less"); }
    else if ordering == Greater { println!("greater"); }
    else if ordering == Equal { println!("equal"); }
}
```

导入值是方便简洁的，不过这也可能导致命名冲突，所以使用时要慎重。因为这个原因，尽量少导入值被认为是一个好的风格。

正如你看到的，`enum`是一个非常强力的数据表示工具，当它是[泛型](http://doc.rust-lang.org/book/generics.html)时则更加有用。当然，在我们讲泛型之前，让我们聊聊如何在在模式匹配中，一个比一堆`if`/`else`更加高明的可以让我们解构集合类型（枚举的类型术语名称）的工具。
