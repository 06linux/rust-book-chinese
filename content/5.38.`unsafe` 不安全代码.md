# 不安全代码
Rust主要魅力是它强大的静态行为保障。不过安全检查天性保守：有些程序实际上是安全的，不过编译器不能验证它是否是真的。为了写这种类型的程序，我们需要告诉编译器稍微放松它的限制。为此，Rust有一个关键字，`unsafe`。使用`unsafe`的代码比正常代码有更少的限制。

让我们过一遍语法，接着我们讨论语义。`unsafe`用在两个上下文中。第一个标记一个函数为不安全的：

```rust
unsafe fn danger_will_robinson() {
    // scary stuff 
}
```

例如所有从[FFI](http://doc.rust-lang.org/nightly/book/ffi.html)调用的函数都必须标记为`unsafe`。第二个`unsafe`的用途是一个不安全块。

```rust
unsafe {
    // scary stuff
}
```

显式勾勒出那些可能会有bug并造成大问题的代码是很重要的。如果一个Rust程序段错误了，你可以确认它位于标记为`unsafe`部分的什么地方。

## “安全”指什么？（What does ‘safe’ mean?）
安全，在Rust的上下文中，意味着“不做任何不安全的事”。简单明了！

好的，让我再试一下：神马是不安全的事？这里是个列表：

* 数据竞争
* 解引用一个空/悬垂裸指针
* 读[`undef`](http://llvm.org/docs/LangRef.html#undefined-values)（未初始化）内存
* 使用裸指针打破[指针混淆规则](http://llvm.org/docs/LangRef.html#pointer-aliasing-rules)
* `&mut T`和`&T`遵循LLVM范围的[`noalias`](http://llvm.org/docs/LangRef.html#noalias)模型，除了如果`&T`包含一个`UnsafeCell<U>`的话。不安全代码必须不能违反这些混淆保证
* 不使用`UnsafeCell<U>`改变一个比可变值/引用
* 通过编译器固有功能调用未定义行为：
  * 使用`std::ptr::offset`（`offset`功能）来索引超过一个对象界限的值，除了结尾后一个字节，这是允许的
  * 使用`std::ptr::copy_nonoverlapping_memory`（`memcpy32/memcpy64`功能）来重叠缓冲区
* 原生类型的无效值，即使是在私有字段/本地变量中：
  * 空/悬垂引用或装箱
  * `bool`中一个不是`false`（`0`）或`true`（`1`）的值
  * `enum`中一个并不包含在类型定义中判别式
  * `char`中一个等于或大于`char::MAX`的值
  * `str`中非UTF-8字节序列
* 
