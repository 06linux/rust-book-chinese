# 迭代器
让我们讨论一下循环。

还记得Rust的`for`循环吗？这是一个例子：
```rust
for x in 0..10 {
    println!("{}", x);
}
```
现在我们更加了解Rust了，我们可以谈谈这里的具体细节了。这个范围（`0..10`）是“迭代器”。我们可以重复调用迭代器的`.next()`方法，然后它会给我们一个数据序列。

就像这样：
```rust
let mut range = 0..10;

loop {
    match range.next() {
        Some(x) => {
            println!("{}", x);
        },
        None => { break }
    }
}
```
我们创建了一个`range`的可变绑定，它是我们的迭代器。我们接着`loop`，它包含一个`match`。`match`用来匹配`range.next()`的结果，它给我们迭代器的下一个值。`next`返回一个`Option<i32>`，在这个例子中，它会返回`Some(i32)`如果有值然后返回`None`当我们循环完毕。如果我们得到`Some(i32)`，我们打印它，如果我们得到`None`，我们`break`出循环。

这个代码例子基本上和我们的`loop`版本一样。`for`只是`loop/match/break`结构的简便写法。

然而，`for`循环并不是唯一使用迭代器的结构。编写你自己的迭代器涉及到实现`Iterator`特性。然而特性不是本章教程的涉及范围，不过Rust提供了一系列的有用的迭代器帮助我们完成各种任务。在我们开始讲解之前，我们需要看看一个Rust的反面模式。这就是如此使用范围。

是的，我们刚刚谈论到范围是多么的酷。不过范围也是非常原始的。例如，如果你想迭代一个向量的内容，你可能尝试这么写：
```rust
let nums = vec![1, 2, 3];

for i in 0..nums.len() {
    println!("{}", nums[i]);
}
```
这严格的说比使用现成的迭代器还要糟。你可以直接在向量上迭代。所以这么写：
```rust
let nums = vec![1, 2, 3];

for num in &nums {
    println!("{}", num);
}
```
这么写有两个原因。第一，它更明确的表明了我们的意图。我们迭代整个向量，而不是先迭代向量的索引，再按索引迭代向量。第二，这个版本也更有效率：第一个版本会进行额外的边界检查因为它使用了索引，`nums[i]`。因为我们利用迭代器获取每个向量元素的引用，第二个例子中并没有边界检查。这在迭代器中非常常见：我们可以忽略不必要的边界检查，不过仍然知道我们是安全的。

这里还有一个细节不是100%清楚的就是`println!`是如何工作的。`num`是`&i32`类型。也就是说，它是一个`i32`的引用，并不是`i32`本身。`println!`为我们处理了非关联化，所以我们看不到。下面的代码也能工作：
```rust
let nums = vec![1, 2, 3];

for num in &nums {
    println!("{}", *num);
}
```
现在我们显式的解引用了`num`。为什么`&nums`会给我们一个引用呢？首先，因为我们显式的使用了`&`。再次，如果它给我们数据，我们就是它的所有者了，这会涉及到生成数据的拷贝然后返回给我们拷贝。通过引用，我们只是借用了一个数据的引用，所以仅仅是传递了一个引用，并不涉及数据的移动。

那么，现在我们已经明确了范围经产不是我们需要的，让我们来讨论下你需要什么。

这里涉及到大体上相关的3类事物：迭代器，*迭代适配器*（*iterator adapters*）和*消费者*（*iterator adapters*）。下面是一些定义：

* *迭代器*给你一个值的序列
* *迭代适配器*操作迭代器，产生一个不同输出序列的新迭代器
* *消费者*操作迭代器，产生最终值的集合

让我们先看看消费者，因为我们已经见过范围这个迭代器了。

## 消费者
*消费者*操作一个迭代器，返回一些值或者几种类型的值。最常见的消费者是`collect()`。这个代码还不能编译，不过它表明了我们的意图：
```rust
let one_to_one_hundred = (1..101).collect();
```
如你所见，我们在迭代器上调用了`collect()`。`collect()`从迭代器中取得尽可能多的值，然后返回结果的集合。那么为什么这不能编译呢？因为Rust不能确定你想收集什么类型的值，所以你需要让它知道。下面是一个可以编译的版本：
```rust
let one_to_one_hundred = (1..101).collect::<Vec<i32>>();
```
如果你还记得，`::<>`语法允许我们给出一个类型提示，所以我们可以告诉编译器我们需要一个整形的向量。但是你并不总是需要提供完整的类型。使用`_`可以让你提供一个部分的提示：
```rust
let one_to_one_hundred = (1..101).collect::<Vec<_>>();
```
这是指“请把值收集到`Vec<T>`，不过自行推断`T`类型”。为此`_`有事被称为“类型占位符”。

`collect()`是最常见的消费者，不过这还有其它的消费者。`find()`就是一个：
```rust
let greater_than_forty_two = (0..100)
                             .find(|x| *x > 42);

match greater_than_forty_two {
    Some(_) => println!("We got some numbers!"),
    None => println!("No numbers found :("),
}
```
`find`接收一个闭包，然后处理迭代器中每个元素的引用。这个闭包返回`true`如果这个元素是我们要找的，返回`false`如果不是。因为我们可能不能找到任何元素，所以`find`返回`Option`而不是元素本身。

另一个重要的消费者是`fold`。他看起来像这样：
```rust
let sum = (1..4).fold(0, |sum, x| sum + x);
```
`fold()`看起来像这样：`fold(base, |accumulator, element| ...)`。
